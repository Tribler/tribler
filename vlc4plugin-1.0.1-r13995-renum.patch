Index: src/control/mediacontrol_core.c
===================================================================
--- src/control/mediacontrol_core.c	(.../trunk)	(revision 13995)
+++ src/control/mediacontrol_core.c	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -409,7 +409,7 @@
         }
 
         retval->url = libvlc_media_get_mrl( p_media, &ex );
-	
+
         retval->position = libvlc_media_player_get_time( self->p_media_player, &ex );
         if( libvlc_exception_raised( &ex ) )
         {
@@ -427,3 +427,42 @@
     }
     return retval;
 }
+
+
+/* added by Ivaylo */
+
+void
+mediacontrol_set_raw_callbacks( mediacontrol_Instance *self,
+                                raw_read_fnc_ptr read_callback,
+                                raw_seek_fnc_ptr seek_callback,
+                                int i_fsize, // Arno: TODO: shouldn't this be int64 like seek's offset?
+                                int id,
+                                mediacontrol_Exception *exception )
+{
+    libvlc_media_t * p_media;
+    libvlc_exception_t ex;
+    char *psz_cmd = NULL;
+
+    mediacontrol_exception_init( exception );
+    libvlc_exception_init( &ex );
+
+
+    /* the cmd is something like
+       raw:rptr=0x12345678:sptr=0x98765432:fsize=314567789:id=4213
+      malloc 4   +5   +19        +5   +19        +6    +12       +3 +12   +1 = 86 bytes.
+     */
+    psz_cmd = ( char * )malloc( 128 * sizeof( char ) );
+    if( psz_cmd )
+    {
+        snprintf( psz_cmd, 128, "raw:rptr=0x%p:sptr=0x%p:fsize=%d:id=%d",
+            read_callback, seek_callback, i_fsize, id);
+
+        p_media = libvlc_media_new( self->p_instance, (const char *)psz_cmd, &ex );
+        HANDLE_LIBVLC_EXCEPTION_VOID( &ex );
+
+        libvlc_media_player_set_media( self->p_media_player, p_media, &ex );
+        HANDLE_LIBVLC_EXCEPTION_VOID( &ex );
+
+        free( psz_cmd ); // libvlc_media_new does strdup of psz_cmd
+    }
+}
Index: src/libvlc.sym
===================================================================
--- src/libvlc.sym	(.../trunk)	(revision 13995)
+++ src/libvlc.sym	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -269,6 +269,7 @@
 mediacontrol_set_media_position
 mediacontrol_set_mrl
 mediacontrol_set_rate
+mediacontrol_set_raw_callbacks
 mediacontrol_set_visual
 mediacontrol_snapshot
 mediacontrol_sound_get_volume
Index: bindings/python/vlcwidget.py
===================================================================
--- bindings/python/vlcwidget.py	(.../trunk)	(revision 0)
+++ bindings/python/vlcwidget.py	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,114 @@
+#! /usr/bin/python
+
+"""VLC Widget classes.
+
+This module provides two helper classes, to ease the embedding of a
+VLC component inside a pygtk application.
+
+VLCWidget is a simple VLC widget.
+
+DecoratedVLCWidget provides simple player controls.
+
+$Id$
+"""
+
+import gtk
+import sys
+import vlc
+
+from gettext import gettext as _
+
+class VLCWidget(gtk.DrawingArea):
+    """Simple VLC widget.
+
+    Its player can be controlled through the 'player' attribute, which
+    is a MediaControl instance.
+    """
+    def __init__(self, *p):
+        gtk.DrawingArea.__init__(self)
+        self.player=vlc.MediaControl(*p)
+        def handle_embed(*p):
+            if sys.platform == 'win32':
+                xidattr='handle'
+            else:
+                xidattr='xid'
+            self.player.set_visual(getattr(self.window, xidattr))
+            return True
+        self.connect("map-event", handle_embed)
+        self.set_size_request(320, 200)
+
+
+class DecoratedVLCWidget(gtk.VBox):
+    """Decorated VLC widget.
+
+    VLC widget decorated with a player control toolbar.
+
+    Its player can be controlled through the 'player' attribute, which
+    is a MediaControl instance.
+    """
+    def __init__(self, *p):
+        gtk.VBox.__init__(self)
+        self._vlc_widget=VLCWidget(*p)
+        self.player=self._vlc_widget.player
+        self.pack_start(self._vlc_widget, expand=True)
+        self._toolbar = self.get_player_control_toolbar()
+        self.pack_start(self._toolbar, expand=False)
+
+    def get_player_control_toolbar(self):
+        """Return a player control toolbar
+        """
+        tb=gtk.Toolbar()
+        tb.set_style(gtk.TOOLBAR_ICONS)
+
+        def on_play(b):
+            self.player.start(0)
+            return True
+
+        def on_stop(b):
+            self.player.stop(0)
+            return True
+
+        def on_pause(b):
+            self.player.pause(0)
+            return True
+
+        tb_list = (
+            (_("Play"), _("Play"), gtk.STOCK_MEDIA_PLAY,
+             on_play),
+            (_("Pause"), _("Pause"), gtk.STOCK_MEDIA_PAUSE,
+             on_pause),
+            (_("Stop"), _("Stop"), gtk.STOCK_MEDIA_STOP,
+             on_stop),
+            )
+
+        for text, tooltip, stock, callback in tb_list:
+            b=gtk.ToolButton(stock)
+            b.connect("clicked", callback)
+            tb.insert(b, -1)
+        tb.show_all()
+        return tb
+
+class VideoPlayer:
+    """Example video player.
+    """
+    def __init__(self):
+        self.vlc = DecoratedVLCWidget()
+
+    def main(self, fname):
+        self.vlc.player.set_mrl(fname)
+        self.popup()
+        gtk.main()
+
+    def popup(self):
+        w=gtk.Window()
+        w.add(self.vlc)
+        w.show_all()
+        w.connect("destroy", gtk.main_quit)
+        return w
+
+if __name__ == '__main__':
+    if not sys.argv[1:]:
+       print "You must provide a movie filename"
+       sys.exit(1)
+    p=VideoPlayer()
+    p.main(sys.argv[1])
Index: bindings/python/vlc_mediaplayer.c
===================================================================
--- bindings/python/vlc_mediaplayer.c	(.../trunk)	(revision 0)
+++ bindings/python/vlc_mediaplayer.c	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,706 @@
+/*****************************************************************************
+ * vlc_mediaplayer.c: vlc.MediaPlayer binding
+ *****************************************************************************
+ * Copyright (C) 2006,2007,2008,2009 the VideoLAN team
+ * $Id$
+ *
+ * Authors: Olivier Aubert <olivier.aubert at liris.cnrs.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+#include "vlcglue.h"
+
+/***********************************************************************
+ * vlc.Input
+ ***********************************************************************/
+
+static PyObject *
+vlcMediaPlayer_get_length( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int64_t i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_media_player_get_length( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "L", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_get_time( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int64_t i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_media_player_get_time( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "L", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_set_time( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int64_t i_time;
+
+    if( !PyArg_ParseTuple( args, "L", &i_time ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_media_player_set_time( LIBVLC_MEDIAPLAYER(self), i_time, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_get_position( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    float f_ret;
+    LIBVLC_TRY;
+    f_ret = libvlc_media_player_get_position( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "f", f_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_set_position( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    float f_pos;
+
+    if( !PyArg_ParseTuple( args, "f", &f_pos ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_media_player_set_position( LIBVLC_MEDIAPLAYER(self), f_pos, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_will_play( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_media_player_will_play( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_get_rate( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    float f_ret;
+    LIBVLC_TRY;
+    f_ret = libvlc_media_player_get_rate( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "f", f_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_set_rate( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    float f_rate;
+
+    if( !PyArg_ParseTuple( args, "f", &f_rate ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_media_player_set_rate( LIBVLC_MEDIAPLAYER(self), f_rate, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_get_state( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_media_player_get_state( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_has_vout( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_media_player_has_vout( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_get_fps( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    float f_ret;
+    LIBVLC_TRY;
+    f_ret = libvlc_media_player_get_fps( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "f", f_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_audio_get_track( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+
+    LIBVLC_TRY;
+    i_ret = libvlc_audio_get_track( LIBVLC_MEDIAPLAYER(self), &ex );
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_audio_set_track( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_track;
+
+    if( !PyArg_ParseTuple( args, "i", &i_track ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_audio_set_track( LIBVLC_MEDIAPLAYER(self), i_track, &ex );
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_get_chapter( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+
+    LIBVLC_TRY;
+    i_ret = libvlc_media_player_get_chapter( LIBVLC_MEDIAPLAYER(self), &ex );
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_get_chapter_count( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+
+    LIBVLC_TRY;
+    i_ret = libvlc_media_player_get_chapter_count( LIBVLC_MEDIAPLAYER(self), &ex );
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_set_chapter( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_chapter;
+
+    if( !PyArg_ParseTuple( args, "i", &i_chapter ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_media_player_set_chapter( LIBVLC_MEDIAPLAYER(self), i_chapter, &ex );
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+
+static PyObject *
+vlcMediaPlayer_toggle_fullscreen( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+
+    LIBVLC_TRY;
+    libvlc_toggle_fullscreen( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_set_fullscreen( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_fullscreen;
+
+    if( !PyArg_ParseTuple( args, "i", &i_fullscreen ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_set_fullscreen( LIBVLC_MEDIAPLAYER(self), i_fullscreen, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_get_fullscreen( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+
+    LIBVLC_TRY;
+    i_ret = libvlc_get_fullscreen( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_get_height( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+
+    LIBVLC_TRY;
+    i_ret = libvlc_video_get_height( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_get_width( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+
+    LIBVLC_TRY;
+    i_ret = libvlc_video_get_width( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_get_aspect_ratio( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_ret;
+    PyObject* o_ret;
+
+    LIBVLC_TRY;
+    psz_ret = libvlc_video_get_aspect_ratio( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    o_ret=Py_BuildValue( "s", psz_ret );
+    free( psz_ret );
+    return o_ret;
+}
+
+static PyObject *
+vlcMediaPlayer_set_aspect_ratio( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_ratio;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_ratio ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_video_set_aspect_ratio( LIBVLC_MEDIAPLAYER(self), psz_ratio, &ex);
+    LIBVLC_EXCEPT;
+    free( psz_ratio );
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_video_take_snapshot( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_filename;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_filename ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_video_take_snapshot( LIBVLC_MEDIAPLAYER(self), psz_filename, 0, 0, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_is_seekable( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_media_player_is_seekable( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_can_pause( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_media_player_can_pause( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_play( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+
+    LIBVLC_TRY;
+    libvlc_media_player_play( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_pause( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+
+    LIBVLC_TRY;
+    libvlc_media_player_pause( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_stop( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+
+    LIBVLC_TRY;
+    libvlc_media_player_stop( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_set_xwindow( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    uint32_t i_drawable;
+
+    if( !PyArg_ParseTuple( args, "i", &i_drawable ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_media_player_set_xwindow( LIBVLC_MEDIAPLAYER(self), i_drawable, &ex );
+    LIBVLC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_get_xwindow( PyObject *self, PyObject *args )
+{
+    uint32_t i_ret;
+
+    i_ret = libvlc_media_player_get_xwindow( LIBVLC_MEDIAPLAYER(self));
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_set_hwnd( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    void* i_drawable;
+
+    if( !PyArg_ParseTuple( args, "l", &i_drawable ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_media_player_set_hwnd( LIBVLC_MEDIAPLAYER(self), (void*) i_drawable, &ex );
+    LIBVLC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_get_hwnd( PyObject *self, PyObject *args )
+{
+    void* i_ret;
+
+    i_ret = libvlc_media_player_get_hwnd( LIBVLC_MEDIAPLAYER(self));
+    return Py_BuildValue( "l", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_set_agl( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    uint32_t i_drawable;
+
+    if( !PyArg_ParseTuple( args, "i", &i_drawable ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_media_player_set_agl( LIBVLC_MEDIAPLAYER(self), i_drawable, &ex );
+    LIBVLC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_get_agl( PyObject *self, PyObject *args )
+{
+    uint32_t i_ret;
+
+    i_ret = libvlc_media_player_get_agl( LIBVLC_MEDIAPLAYER(self));
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_set_nsobject( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    void* i_drawable;
+
+    if( !PyArg_ParseTuple( args, "l", &i_drawable ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_media_player_set_nsobject( LIBVLC_MEDIAPLAYER(self), (void*) i_drawable, &ex );
+    LIBVLC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_get_nsobject( PyObject *self, PyObject *args )
+{
+    void* i_ret;
+
+    i_ret = libvlc_media_player_get_nsobject( LIBVLC_MEDIAPLAYER(self));
+    return Py_BuildValue( "l", i_ret );
+}
+
+
+static PyObject *
+vlcMediaPlayer_set_media( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    PyObject* py_param = NULL;
+
+    if( !PyArg_ParseTuple( args, "O", &py_param ) )
+        return NULL;
+    if( PyObject_TypeCheck( py_param, &vlcMedia_Type ) == 1 )
+    {
+        LIBVLC_TRY;
+        libvlc_media_player_set_media( LIBVLC_MEDIAPLAYER(self), ((vlcMedia*)py_param)->p_media, &ex );
+        LIBVLC_EXCEPT;
+    }
+    else
+    {
+        PyObject *py_exc = vlc_Exception;
+        PyErr_SetString( py_exc, "vlc.Media parameter needed" );
+        return NULL;
+    }
+    return NULL;
+}
+
+static PyObject *
+vlcMediaPlayer_get_media( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    libvlc_media_t *p_media;
+    vlcMedia *p_ret;
+
+    LIBVLC_TRY;
+    p_media = libvlc_media_player_get_media( LIBVLC_MEDIAPLAYER(self), &ex );
+    LIBVLC_EXCEPT;
+
+    if( !p_media )
+    {
+        Py_INCREF( Py_None );
+        return Py_None;
+    }
+    else
+    {
+        p_ret = PyObject_New( vlcMedia, &vlcMedia_Type );
+        p_ret->p_media = p_media;
+        Py_INCREF( p_ret ); /* Ah bon ? */
+        return ( PyObject * )p_ret;
+    }
+}
+
+static PyObject *
+vlcMediaPlayer_get_spu( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_video_get_spu( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_set_spu( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_spu;
+
+    if( !PyArg_ParseTuple( args, "i", &i_spu ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_video_set_spu( LIBVLC_MEDIAPLAYER(self), i_spu, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+
+static PyMethodDef vlcMediaPlayer_methods[] =
+{
+    { "get_length", vlcMediaPlayer_get_length, METH_VARARGS,
+      "get_length() -> long    " },
+    { "get_time", vlcMediaPlayer_get_time, METH_VARARGS,
+      "get_time() -> long" },
+    { "set_time", vlcMediaPlayer_set_time, METH_VARARGS,
+      "set_time(long)" },
+    { "get_position", vlcMediaPlayer_get_position, METH_VARARGS,
+      "get_position() -> float" },
+    { "set_position", vlcMediaPlayer_set_position, METH_VARARGS,
+      "set_position(float)" },
+    { "will_play", vlcMediaPlayer_will_play, METH_VARARGS,
+      "will_play() -> int" },
+    { "is_seekable", vlcMediaPlayer_is_seekable, METH_VARARGS,
+      "is_seekable() -> int" },
+    { "can_pause", vlcMediaPlayer_can_pause, METH_VARARGS,
+      "can_pause() -> int" },
+    { "get_rate", vlcMediaPlayer_get_rate, METH_VARARGS,
+      "get_rate() -> float" },
+    { "set_rate", vlcMediaPlayer_set_rate, METH_VARARGS,
+      "set_rate(float)" },
+    { "get_state", vlcMediaPlayer_get_state, METH_VARARGS,
+      "get_state() -> int" },
+    { "has_vout", vlcMediaPlayer_has_vout, METH_VARARGS,
+      "has_vout() -> int" },
+    { "get_fps", vlcMediaPlayer_get_fps, METH_VARARGS,
+      "get_fps() -> float" },
+    { "audio_get_track", vlcMediaPlayer_audio_get_track, METH_VARARGS,
+      "audio_get_track() -> int    Get current audio track" },
+    { "audio_set_track", vlcMediaPlayer_audio_set_track, METH_VARARGS,
+      "audio_set_track(int)        Set current audio track" },
+    { "toggle_fullscreen", vlcMediaPlayer_toggle_fullscreen, METH_VARARGS,
+      "toggle_fullscreen()    Toggle fullscreen status on video output" },
+    { "set_fullscreen", vlcMediaPlayer_set_fullscreen, METH_VARARGS,
+      "set_fullscreen(bool)    Enable or disable fullscreen on a video output" },
+    { "get_fullscreen", vlcMediaPlayer_get_fullscreen, METH_VARARGS,
+      "get_fullscreen() -> bool    Get current fullscreen status" },
+    { "get_height", vlcMediaPlayer_get_height, METH_VARARGS,
+      "get_height() -> int           Get current video height" },
+    { "get_width", vlcMediaPlayer_get_width, METH_VARARGS,
+      "get_width() -> int           Get current video width" },
+    { "get_aspect_ratio", vlcMediaPlayer_get_aspect_ratio, METH_VARARGS,
+      "get_aspect_ratio() -> str    Get current video aspect ratio" },
+    { "set_aspect_ratio", vlcMediaPlayer_set_aspect_ratio, METH_VARARGS,
+      "set_aspect_ratio(str)        Set new video aspect ratio" },
+    { "video_take_snapshot", vlcMediaPlayer_video_take_snapshot, METH_VARARGS,
+      "video_take_snapshot(filename=str)        Take a snapshot of the current video window" },
+
+    { "play", vlcMediaPlayer_play, METH_VARARGS,
+      "play()    Play the media instance" },
+    { "pause", vlcMediaPlayer_pause, METH_VARARGS,
+      "pause()   Pause the media instance" },
+    { "stop", vlcMediaPlayer_stop, METH_VARARGS,
+      "stop()    Stop the media instance" },
+#ifdef OLD
+    { "set_drawable", vlcMediaPlayer_set_drawable, METH_VARARGS,
+      "set_drawable()    Set the drawable id" },
+#endif
+    { "get_chapter", vlcMediaPlayer_get_chapter, METH_VARARGS,
+      "get_chapter() -> int    Get current chapter" },
+    { "set_chapter", vlcMediaPlayer_set_chapter, METH_VARARGS,
+      "set_chapter(int)        Set current chapter" },
+    { "get_chapter_count", vlcMediaPlayer_get_chapter_count, METH_VARARGS,
+      "get_chapter_count() -> int    Get current chapter count" },
+
+    { "set_media", vlcMediaPlayer_set_media, METH_VARARGS,
+      "set_media(vlc.Media)        Set the media that will be used by the media_player" },
+    { "get_media", vlcMediaPlayer_get_media, METH_VARARGS,
+      "get_media() -> vlc.Media    Get the media used by the media_player (if any)." },
+
+    { "get_spu", vlcMediaPlayer_get_spu, METH_VARARGS,
+      "get_spu() -> int   Get current video subtitle" },
+    { "set_spu", vlcMediaPlayer_set_spu, METH_VARARGS,
+      "set_spu(int)      Set new video subtitle" },
+
+    { NULL }  /* Sentinel */
+};
+
+static PyTypeObject vlcMediaPlayer_Type =
+{
+    PyObject_HEAD_INIT( NULL )
+    0,                         /*ob_size*/
+    "vlc.MediaPlayer",            /*tp_name*/
+    sizeof( vlcMediaPlayer_Type ),   /*tp_basicsize*/
+    0,                         /*tp_itemsize*/
+    0,                         /*tp_dealloc*/
+    0,                         /*tp_print*/
+    0,                         /*tp_getattr*/
+    0,                         /*tp_setattr*/
+    0,                         /*tp_compare*/
+    0,                         /*tp_repr*/
+    0,                         /*tp_as_number*/
+    0,                         /*tp_as_sequence*/
+    0,                         /*tp_as_mapping*/
+    0,                         /*tp_hash */
+    0,                         /*tp_call*/
+    0,                         /*tp_str*/
+    0,                         /*tp_getattro*/
+    0,                         /*tp_setattro*/
+    0,                         /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
+    "vlc.MediaPlayer object\n\nIt cannot be instantiated standalone, it must be obtained from an existing vlc.Instance object",  /* tp_doc */
+    0,                        /* tp_traverse */
+    0,                        /* tp_clear */
+    0,                         /* tp_richcompare */
+    0,                         /* tp_weaklistoffset */
+    0,                         /* tp_iter */
+    0,                          /* tp_iternext */
+    vlcMediaPlayer_methods,          /* tp_methods */
+    0,                         /* tp_members */
+    0,                         /* tp_getset */
+    0,                         /* tp_base */
+    0,                         /* tp_dict */
+    0,                         /* tp_descr_get */
+    0,                         /* tp_descr_set */
+    0,                         /* tp_dictoffset */
+    0,                         /* tp_init */
+    0,                         /* tp_alloc */
+    0,                         /* tp_new */
+};
+
Index: bindings/python/arno-compile-mingw32.sh
===================================================================
--- bindings/python/arno-compile-mingw32.sh	(.../trunk)	(revision 0)
+++ bindings/python/arno-compile-mingw32.sh	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,20 @@
+#
+# VLC docs (http://wiki.videolan.org/Python_bindings) say that 
+#    python setup.py build --compiler=mingw32
+#
+# will compile the bindings. This currently doesn't work for me. 
+# Instead:
+#  1. Obtain Python 2.5.4 source, extract in one dir above vlc source
+#     dir. 
+#  2. Remove test for cross-compilation from test %zd printf() format
+#     support from Python's configure script.
+#  3. Configure Python for cross-compile:
+#  $ ./configure --host=mingw32 --with-gcc=i586-mingw32msvc-gcc --with-cxx=i586-mingw32msvc-g++ --enable-shared --with-threads
+# 4. Obtain python25.dll for Python 2.5.4 from \windows\system32 after
+#    Python 2.5.4 binary installer was run on a Windows box, put in 
+#    one dir above vlc source dir.
+# 5. Run below commands:
+#
+
+i586-mingw32msvc-gcc -mthreads -fno-strict-aliasing -g -O3 -Wall -Wstrict-prototypes  -I../.. -I./../../include -I/usr/win32/include -I../../../Python-2.5.4 -I../../../Python-2.5.4/Include -c ./vlc_module.c -o ../../bindings/python/./vlc_module.o -D_FILE_OFFSET_BITS=64 -D__USE_UNIX98 -D_LARGEFILE64_SOURCE -D_REENTRANT -D_THREAD_SAFE -D_GNU_SOURCE  -O3 -ffast-math -funroll-loops -mtune=pentium2 -g
+i586-mingw32msvc-g++  -Wsign-compare -Wall -mms-bitfields -pipe -shared ../../bindings/python/./vlc_module.o ../../src/.libs/libvlc.dll.a ../../../python25.dll -o ../../bindings/python/vlc.pyd -g -lkernel32 -L/usr/win32/lib -liconv /usr/win32/lib/libintl.a /usr/win32/lib/libiconv.a -lws2_32 -lnetapi32 -lwinmm -mwindows 
Index: bindings/python/debian/control
===================================================================
--- bindings/python/debian/control	(.../trunk)	(revision 0)
+++ bindings/python/debian/control	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,15 @@
+Source: python-vlc
+Section: contrib/libs
+Priority: optional
+Maintainer: Jason Scheunemann <jason.scheunemann@yahoo.com>
+Build-Depends: cdbs, debhelper (>= 7), python-central (>=0.5.6), python-setuptools, python-dev, libvlc-dev (>= 1.0.0)
+XS-Python-Version: 2.5
+Standards-Version: 3.8.0
+Homepage: http://wiki.videolan.org/PythonBinding
+
+Package: python-vlc
+Architecture: any
+XB-Python-Version: ${python:Versions}
+Depends: ${python:Depends}, ${misc:Depends}, vlc (>= 1.0.0)
+Description: VLC bindings for python.
+ VLC bindings for python.
Index: bindings/python/debian/rules
===================================================================
--- bindings/python/debian/rules	(.../trunk)	(revision 0)
+++ bindings/python/debian/rules	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,8 @@
+#!/usr/bin/make -f
+
+DEB_PYTHON_SYSTEM=pycentral
+
+include /usr/share/cdbs/1/rules/debhelper.mk
+include /usr/share/cdbs/1/class/python-distutils.mk
+
+# Add here any variable or target overrides you need.
Index: bindings/python/vlc_media.c
===================================================================
--- bindings/python/vlc_media.c	(.../trunk)	(revision 0)
+++ bindings/python/vlc_media.c	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,228 @@
+/*****************************************************************************
+ * vlc_media.c: vlc.Media binding
+ *****************************************************************************
+ * Copyright (C) 2007 the VideoLAN team
+ * $Id$
+ *
+ * Authors: Olivier Aubert <olivier.aubert at liris.cnrs.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+#include "vlcglue.h"
+
+/***********************************************************************
+ * vlc.Media
+ ***********************************************************************/
+
+static PyObject *
+vlcMedia_new( PyTypeObject *type, PyObject *args, PyObject *kwds )
+{
+    fprintf(stderr, "vlcMedia_new called\n");
+    PyErr_SetString( PyExc_TypeError, "vlc.Media can be instantiated by itself. You should use vlc.Instance().media_new(mrl)." );
+    return NULL;
+}
+
+static void
+vlcMedia_dealloc( PyObject *self )
+{
+    libvlc_media_release( LIBVLC_MEDIA(self) );
+    PyObject_DEL( self );
+}
+
+static PyObject *
+vlcMedia_add_option( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_options = NULL;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_options ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_media_add_option( LIBVLC_MEDIA(self), psz_options, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMedia_get_mrl( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char * psz_mrl;
+    PyObject * o_ret;
+
+    LIBVLC_TRY;
+    psz_mrl = libvlc_media_get_mrl( LIBVLC_MEDIA(self), &ex);
+    LIBVLC_EXCEPT;
+
+    o_ret = Py_BuildValue( "s", psz_mrl );
+    free( psz_mrl );
+    return o_ret;
+}
+
+static PyObject *
+vlcMedia_get_state( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    libvlc_state_t i_state;
+
+    LIBVLC_TRY;
+    i_state = libvlc_media_get_state( LIBVLC_MEDIA(self), &ex);
+    LIBVLC_EXCEPT;
+    /* FIXME: return the defined state constant */
+    return Py_BuildValue( "i", i_state );
+}
+
+static PyObject *
+vlcMedia_get_duration( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    libvlc_time_t i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_media_get_duration( LIBVLC_MEDIA(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "L", i_ret );
+}
+
+static PyObject *
+vlcMedia_media_player_new( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    libvlc_media_player_t *p_mp;
+    vlcMediaPlayer *p_ret;
+
+    LIBVLC_TRY;
+    p_mp = libvlc_media_player_new_from_media( LIBVLC_MEDIA(self), &ex);
+    LIBVLC_EXCEPT;
+
+    p_ret = PyObject_New( vlcMediaPlayer, &vlcMediaPlayer_Type );
+    p_ret->p_mp = p_mp;
+    Py_INCREF( p_ret ); /* Ah bon ? */
+    return ( PyObject * )p_ret;
+}
+
+static PyObject *
+vlcMedia_is_preparsed( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_media_is_preparsed( LIBVLC_MEDIA(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "L", i_ret );
+}
+
+static PyObject *
+vlcMedia_get_meta( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char * psz_meta = NULL;
+    char * psz_ret = NULL;
+    PyObject* o_ret;
+    int i_index = -1;
+    int i_loop = 0;
+    static const char * meta_names[] = { "Title", "Artist", "Genre", "Copyright", "Album", "TrackNumber", "Description", "Rating", "Date", "Setting", "URL", "Language", "NowPlaying", "Publisher", "EncodedBy", "ArtworkURL", "TrackID", NULL };
+
+    if( !PyArg_ParseTuple( args, "s", &psz_meta ) )
+        return NULL;
+    while( meta_names[i_loop] )
+    {
+        if( !strncmp(meta_names[i_loop], psz_meta, strlen(meta_names[i_loop])) )
+        {
+            i_index = i_loop;
+            break;
+        }
+        i_loop++;
+    }
+    if( i_index < 0 )
+    {
+        PyObject *py_exc = vlc_Exception;
+        PyErr_SetString( py_exc, "Unknown meta attribute" );
+        return NULL;
+    }
+
+    LIBVLC_TRY;
+    psz_ret = libvlc_media_get_meta( LIBVLC_MEDIA(self), i_index, &ex);
+    LIBVLC_EXCEPT;
+
+    o_ret = Py_BuildValue( "s", psz_ret );
+    free( psz_ret );
+    return o_ret;
+}
+
+static PyMethodDef vlcMedia_methods[] =
+{
+    { "add_option", vlcMedia_add_option, METH_VARARGS,
+      "add_option(str) Add an option to the media." },
+    { "get_mrl", vlcMedia_get_mrl, METH_VARARGS,
+      "get_mrl() -> str" },
+    { "get_state", vlcMedia_get_state, METH_VARARGS,
+      "get_state() -> int" },
+    { "get_duration", vlcMedia_get_duration, METH_VARARGS,
+      "get_duration() -> int" },
+    { "mediaplayer_new", vlcMedia_media_player_new, METH_VARARGS,
+      "mediaplayer_new() -> vlc.MediaPlayer   Create a MediaPlayer object from a Media" },
+    { "is_preparsed", vlcMedia_is_preparsed, METH_VARARGS,
+      "is_preparsed() -> int" },
+    { "get_meta", vlcMedia_get_meta, METH_VARARGS,
+      "get_meta(str) -> str   Read the meta of the media." },
+
+    { NULL }  /* Sentinel */
+};
+
+static PyTypeObject vlcMedia_Type =
+{
+    PyObject_HEAD_INIT( NULL )
+    0,                         /*ob_size*/
+    "vlc.Media",            /*tp_name*/
+    sizeof( vlcMedia_Type ),   /*tp_basicsize*/
+    0,                         /*tp_itemsize*/
+    vlcMedia_dealloc, /*tp_dealloc*/
+    0,                         /*tp_print*/
+    0,                         /*tp_getattr*/
+    0,                         /*tp_setattr*/
+    0,                         /*tp_compare*/
+    0,                         /*tp_repr*/
+    0,                         /*tp_as_number*/
+    0,                         /*tp_as_sequence*/
+    0,                         /*tp_as_mapping*/
+    0,                         /*tp_hash */
+    0,                         /*tp_call*/
+    0,                         /*tp_str*/
+    0,                         /*tp_getattro*/
+    0,                         /*tp_setattro*/
+    0,                         /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
+    "vlc.Media object.",  /* tp_doc */
+    0,                        /* tp_traverse */
+    0,                        /* tp_clear */
+    0,                         /* tp_richcompare */
+    0,                         /* tp_weaklistoffset */
+    0,                         /* tp_iter */
+    0,                          /* tp_iternext */
+    vlcMedia_methods,          /* tp_methods */
+    0,                         /* tp_members */
+    0,                         /* tp_getset */
+    0,                         /* tp_base */
+    0,                         /* tp_dict */
+    0,                         /* tp_descr_get */
+    0,                         /* tp_descr_set */
+    0,                         /* tp_dictoffset */
+    0,                         /* tp_init */
+    0,                         /* tp_alloc */
+    vlcMedia_new,              /* tp_new */
+};
+
Index: bindings/python/vlc_mediacontrol.c
===================================================================
--- bindings/python/vlc_mediacontrol.c	(.../trunk)	(revision 0)
+++ bindings/python/vlc_mediacontrol.c	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,760 @@
+/*****************************************************************************
+ * vlc_mediacontrol.c: vlc.MediaControl binding
+ *****************************************************************************
+ * Copyright (C) 2006,2007,2008,2009 the VideoLAN team
+ * $Id$
+ *
+ * Authors: Olivier Aubert <olivier.aubert at liris.cnrs.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+#include "vlcglue.h"
+
+/*****************************************************************************
+ * VLC MediaControl object implementation
+ *****************************************************************************/
+
+/* The MediaControl constructor takes either an existing vlc.Instance or a
+   list of strings */
+static PyObject *
+MediaControl_new( PyTypeObject *type, PyObject *args, PyObject *kwds )
+{
+    MediaControl *self;
+    mediacontrol_Exception *exception = NULL;
+    PyObject* py_param = NULL;
+    char** ppsz_args = NULL;
+    libvlc_instance_t* p_instance = NULL;
+    Py_ssize_t i_size = 0;
+
+    self = PyObject_New( MediaControl, &MediaControl_Type );
+
+    fprintf (stderr, "Instantiating mediacontrol\n");
+    if( PyArg_ParseTuple( args, "O", &py_param ) )
+    {
+        if( PyObject_TypeCheck( py_param, &vlcInstance_Type ) == 1 )
+        {
+            p_instance = ((vlcInstance*)py_param)->p_instance;
+        }
+        else
+        {
+            Py_ssize_t i_index;
+
+            Py_INCREF( py_param );
+            if( ! PySequence_Check( py_param ) )
+            {
+                PyErr_SetString( PyExc_TypeError, "Parameter must be a vlc.Instance or a sequence of strings." );
+                Py_DECREF( py_param );
+                return NULL;
+            }
+            i_size = PySequence_Size( py_param );
+            ppsz_args = malloc( ( i_size + 1 ) * sizeof( char * ) );
+            if( ! ppsz_args )
+            {
+                PyErr_SetString( PyExc_MemoryError, "Out of memory" );
+                Py_DECREF( py_param );
+                return NULL;
+            }
+
+            for ( i_index = 0; i_index < i_size; i_index++ )
+            {
+                ppsz_args[i_index] =
+                    strdup( PyString_AsString( PyObject_Str(
+                                                   PySequence_GetItem( py_param,
+                                                                       i_index ) ) ) );
+            }
+            ppsz_args[i_size] = NULL;
+            Py_DECREF( py_param );
+        }
+    }
+    else
+    {
+        /* No arguments were given. Clear the exception raised
+           by PyArg_ParseTuple. */
+        PyErr_Clear( );
+    }
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    if( p_instance )
+    {
+        self->mc = mediacontrol_new_from_instance( p_instance, exception );
+        Py_INCREF( py_param );
+        self->vlc_instance = ( vlcInstance* ) py_param;
+    }
+    else
+    {
+        self->mc = mediacontrol_new( i_size, ppsz_args, exception );
+        self->vlc_instance = PyObject_New( vlcInstance, &vlcInstance_Type );
+        self->vlc_instance->p_instance = mediacontrol_get_libvlc_instance( LIBVLC_MC(self) );
+    }
+    MC_EXCEPT;
+    Py_END_ALLOW_THREADS
+
+    Py_INCREF( self );
+    return ( PyObject * )self;
+}
+
+static void
+MediaControl_dealloc( PyObject *self )
+{
+    fprintf(stderr, "MC dealloc\n");
+    Py_DECREF( ((MediaControl*)self)->vlc_instance );
+    PyObject_DEL( self );
+}
+
+static PyObject *
+MediaControl_get_vlc_instance( PyObject *self, PyObject *args )
+{
+    vlcInstance *p_ret;
+
+    p_ret = ((MediaControl*)self)->vlc_instance;
+    Py_INCREF( p_ret );
+    return ( PyObject * )p_ret;
+}
+
+static PyObject *
+MediaControl_get_mediaplayer( PyObject *self, PyObject *args )
+{
+    vlcMediaPlayer *p_ret;
+
+    p_ret = PyObject_New( vlcMediaPlayer, &vlcMediaPlayer_Type );
+    p_ret->p_mp = mediacontrol_get_media_player( LIBVLC_MC(self) );
+    Py_INCREF( p_ret );
+    return ( PyObject * )p_ret;
+}
+
+/**
+ *  Return the current position in the stream. The returned value can
+   be relative or absolute ( according to PositionOrigin ) and the unit
+   is set by PositionKey
+ */
+static PyObject *
+MediaControl_get_media_position( PyObject *self, PyObject *args )
+{
+    mediacontrol_Position* pos;
+    mediacontrol_Exception* exception = NULL;
+    PyObject *py_origin;
+    PyObject *py_key;
+    PyObject *py_retval;
+    mediacontrol_PositionOrigin origin;
+    mediacontrol_PositionKey key;
+
+    if( !PyArg_ParseTuple( args, "OO", &py_origin, &py_key ) )
+        return NULL;
+
+    origin = positionOrigin_py_to_c( py_origin );
+    key    = positionKey_py_to_c( py_key );
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    pos = mediacontrol_get_media_position( LIBVLC_MC(self), origin, key, exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    py_retval = ( PyObject* )position_c_to_py( pos );
+    free( pos );
+    return py_retval;
+}
+
+/** Set the media position */
+static PyObject *
+MediaControl_set_media_position( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception* exception = NULL;
+    mediacontrol_Position *a_position;
+    PyObject *py_pos;
+
+    if( !PyArg_ParseTuple( args, "O", &py_pos ) )
+        return NULL;
+
+    a_position = position_py_to_c( py_pos );
+    if( !a_position )
+    {
+        PyErr_SetString( PyExc_MemoryError, "Out of memory" );
+        return NULL;
+    }
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_set_media_position( LIBVLC_MC(self), a_position, exception );
+    free( a_position );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+MediaControl_start( PyObject *self, PyObject *args )
+{
+    mediacontrol_Position *a_position;
+    mediacontrol_Exception *exception = NULL;
+    PyObject *py_pos;
+
+    if( !PyArg_ParseTuple( args, "O", &py_pos ) )
+    {
+        /* No argument. Use a default 0 value. */
+        PyErr_Clear( );
+        py_pos = NULL;
+    }
+    a_position = position_py_to_c( py_pos );
+    if( !a_position )
+        return NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_start( LIBVLC_MC(self), a_position, exception );
+    free( a_position );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+MediaControl_pause( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception *exception = NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_pause( LIBVLC_MC(self), exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+  Py_INCREF( Py_None );
+  return Py_None;
+}
+
+static PyObject *
+MediaControl_resume( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception *exception = NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_resume( LIBVLC_MC(self), exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+MediaControl_stop( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception *exception = NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_stop( LIBVLC_MC(self), exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+MediaControl_exit( PyObject *self, PyObject *args )
+{
+    mediacontrol_exit( LIBVLC_MC(self) );
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+MediaControl_set_mrl( PyObject *self, PyObject *args )
+{
+    char *psz_file;
+    mediacontrol_Exception *exception = NULL;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_file ) )
+      return NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_set_mrl( LIBVLC_MC(self), psz_file, exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+MediaControl_get_mrl( PyObject *self, PyObject *args )
+{
+    PyObject *py_retval;
+    char* psz_file;
+    mediacontrol_Exception *exception = NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    psz_file = mediacontrol_get_mrl( LIBVLC_MC(self), exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    py_retval = Py_BuildValue( "s", psz_file );
+    free( psz_file );
+    return py_retval;
+}
+
+static PyObject *
+MediaControl_snapshot( PyObject *self, PyObject *args )
+{
+    mediacontrol_RGBPicture *p_retval = NULL;
+    mediacontrol_Exception* exception = NULL;
+    mediacontrol_Position *a_position = NULL;
+    PyObject *py_pos = NULL;
+    PyObject *py_obj = NULL;
+
+    if( !PyArg_ParseTuple( args, "O", &py_pos ) )
+      return NULL;
+
+    a_position = position_py_to_c( py_pos );
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    p_retval = mediacontrol_snapshot( LIBVLC_MC(self), a_position, exception );
+    free( a_position );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    if( !p_retval )
+    {
+        Py_INCREF( Py_None );
+        return Py_None;
+    }
+
+    /* FIXME: create a real RGBPicture object */
+    py_obj = PyDict_New();
+
+    PyDict_SetItemString( py_obj, "width",
+                          Py_BuildValue( "i", p_retval->width ) );
+    PyDict_SetItemString( py_obj, "height",
+                          Py_BuildValue( "i", p_retval->height ) );
+    PyDict_SetItemString( py_obj, "type",
+                          Py_BuildValue( "i", p_retval->type ) );
+    PyDict_SetItemString( py_obj, "data",
+                          Py_BuildValue( "s#", p_retval->data, p_retval->size ) );
+    PyDict_SetItemString( py_obj, "date",
+                          Py_BuildValue( "L", p_retval->date ) );
+
+    mediacontrol_RGBPicture__free( p_retval );
+
+    return py_obj;
+}
+
+static PyObject*
+MediaControl_display_text( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception* exception = NULL;
+    PyObject *py_begin, *py_end;
+    char* message;
+    mediacontrol_Position * begin;
+    mediacontrol_Position * end;
+
+    if( !PyArg_ParseTuple( args, "sOO", &message, &py_begin, &py_end ) )
+        return NULL;
+
+    begin = position_py_to_c( py_begin );
+    end   = position_py_to_c( py_end );
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_display_text( LIBVLC_MC(self), message, begin, end, exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    free( begin );
+    free( end );
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject*
+MediaControl_get_stream_information( PyObject *self, PyObject *args )
+{
+    mediacontrol_StreamInformation *retval  = NULL;
+    mediacontrol_Exception* exception = NULL;
+    PyObject *py_obj;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    retval = mediacontrol_get_stream_information(
+        LIBVLC_MC(self), mediacontrol_MediaTime, exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    py_obj = PyDict_New( );
+
+     /* FIXME: create a real StreamInformation object */
+    PyDict_SetItemString( py_obj, "status",
+                  Py_BuildValue( "i", retval->streamstatus ) );
+    PyDict_SetItemString( py_obj, "url",
+                  Py_BuildValue( "s", retval->url ) );
+    PyDict_SetItemString( py_obj, "position",
+                  Py_BuildValue( "L", retval->position ) );
+    PyDict_SetItemString( py_obj, "length",
+                  Py_BuildValue( "L", retval->length ) );
+
+    mediacontrol_StreamInformation__free( retval );
+
+    return py_obj;
+}
+
+static PyObject*
+MediaControl_sound_set_volume( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception* exception = NULL;
+    unsigned short volume;
+
+    if( !PyArg_ParseTuple( args, "H", &volume ) )
+        return NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_sound_set_volume( LIBVLC_MC(self), volume, exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject*
+MediaControl_sound_get_volume( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception* exception = NULL;
+    PyObject *py_retval;
+    unsigned short volume;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    volume = mediacontrol_sound_get_volume( LIBVLC_MC(self), exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    py_retval = Py_BuildValue( "H", volume );
+    return py_retval;
+}
+
+static PyObject*
+MediaControl_set_rate( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception* exception = NULL;
+    int rate;
+
+    if( !PyArg_ParseTuple( args, "i", &rate ) )
+        return NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_set_rate( LIBVLC_MC(self), rate, exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject*
+MediaControl_get_rate( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception* exception = NULL;
+    PyObject *py_retval;
+    int rate;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    rate = mediacontrol_get_rate( LIBVLC_MC(self), exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    py_retval = Py_BuildValue( "i", rate );
+    return py_retval;
+}
+
+static PyObject*
+MediaControl_set_fullscreen( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception* exception = NULL;
+    int fs;
+
+    if( !PyArg_ParseTuple( args, "i", &fs ) )
+        return NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_set_fullscreen( LIBVLC_MC(self), fs, exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject*
+MediaControl_get_fullscreen( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception* exception = NULL;
+    PyObject *py_retval;
+    int fs;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    fs = mediacontrol_get_fullscreen( LIBVLC_MC(self), exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    py_retval = Py_BuildValue( "i", fs );
+    return py_retval;
+}
+
+static PyObject*
+MediaControl_set_visual( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception* exception = NULL;
+    WINDOWHANDLE visual;
+
+    if( !PyArg_ParseTuple( args, "i", &visual ) )
+       return NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_set_visual( LIBVLC_MC(self), visual, exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+
+/*
+ *  added by Ivaylo
+ */
+
+/* see
+ http://docs.python.org/api/api.html
+ http://www.python.org/doc/current/ext/callingPython.html
+ http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/65210
+ http://www.suttoncourtenay.org.uk/duncan/accu/integratingpython.html */
+
+
+static int read_callback_wrapper(uint8_t *p_data, int i_data, int id)
+{
+    int retvalue = 0;
+	PyObject *py_buffer = NULL;
+	PyObject *result = NULL;
+	PyGILState_STATE gstate;
+
+
+	gstate = PyGILState_Ensure();
+
+	/* Convert the arguments to a writable buffer object */
+	py_buffer = PyBuffer_FromReadWriteMemory(p_data, i_data);
+
+    if (PyErr_Occurred()) {
+		Py_XDECREF(py_buffer);
+		PyGILState_Release(gstate);
+		return 0;
+    }
+
+    /* Build up the argument list...  */
+
+
+	if (!PyCallable_Check(py_read_callback)) {
+		PyGILState_Release(gstate);
+		return 0;
+	}
+
+    /* ...for calling the Python callback read function. */
+    result = PyObject_CallFunction(py_read_callback,"Oii", py_buffer, i_data, id);
+    if (result && PyInt_Check(result)) {
+        retvalue = PyInt_AsLong(result);
+    }
+    Py_XDECREF(result);
+    Py_XDECREF(py_buffer);
+	PyGILState_Release(gstate);
+
+    return retvalue;
+}
+
+static int seek_callback_wrapper(int64_t i_pos, int id)
+{
+    int retvalue = 0;
+	PyObject *arglist;
+	PyObject *result = NULL;
+	PyGILState_STATE gstate;
+
+	gstate = PyGILState_Ensure();
+
+
+    /* Build up the argument list...  */
+    arglist = Py_BuildValue("(Li)", i_pos, id); // Arno, 2009-08-25: was (li), incorrect, pos is long long int
+
+    /* ...for calling the Python callback seek function. */
+    result = PyEval_CallObject(py_seek_callback,arglist);
+
+    if (result && PyInt_Check(result)) {
+        retvalue = PyInt_AsLong(result);
+    }
+
+    Py_XDECREF(result);
+    Py_DECREF(arglist);
+
+	PyGILState_Release(gstate);
+    return retvalue;
+}
+
+static PyObject *
+MediaControl_set_raw_callbacks(PyObject *self, PyObject *args)
+{
+    PyObject *py_read_cbk;
+    PyObject *py_seek_cbk;
+	int i_fsize;
+	int id;
+    mediacontrol_Exception *exception = NULL;
+
+    if (!PyArg_ParseTuple(args, "OOii", &py_read_cbk, &py_seek_cbk, &i_fsize, &id))
+        return NULL;
+
+    /* make sure the arguments are functions */
+    if (!PyCallable_Check(py_read_cbk) || !PyCallable_Check(py_seek_cbk))
+        PyErr_SetString(PyExc_TypeError, "Need a callable object!");
+    else {
+		Py_XINCREF(py_read_cbk);
+		Py_XINCREF(py_seek_cbk);
+		Py_XDECREF(py_read_callback);
+		Py_XDECREF(py_read_callback);
+		/* set the global callback pointers */
+		py_read_callback = py_read_cbk;
+		py_seek_callback = py_seek_cbk;
+
+		Py_BEGIN_ALLOW_THREADS
+		MC_TRY;
+		/* announce the callbacks to the raw access module */
+		mediacontrol_set_raw_callbacks( LIBVLC_MC(self),
+			read_callback_wrapper, seek_callback_wrapper, i_fsize, id, exception );
+
+		Py_END_ALLOW_THREADS
+	    MC_EXCEPT;
+
+    }
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+
+static PyMethodDef MediaControl_methods[] =
+{
+    { "get_vlc_instance", MediaControl_get_vlc_instance, METH_VARARGS,
+      "get_vlc_instance( ) -> Instance    Get embedded vlc.Instance." },
+    { "get_mediaplayer", MediaControl_get_mediaplayer, METH_VARARGS,
+      "get_mediaplayer( ) -> MediaPlayer    Get embedded vlc.MediaPlayer." },
+    { "get_media_position", MediaControl_get_media_position, METH_VARARGS,
+      "get_media_position( origin, key ) -> Position    Get current media position." },
+    { "set_media_position", MediaControl_set_media_position, METH_VARARGS,
+      "set_media_position( Position )            Set media position" },
+    { "start", MediaControl_start, METH_VARARGS,
+      "start( Position )         Start the player." },
+    { "pause", MediaControl_pause, METH_VARARGS,
+      "pause( Position )         Pause the player." },
+    { "resume", MediaControl_resume, METH_VARARGS,
+      "resume( Position )        Resume the player" },
+    { "stop", MediaControl_stop, METH_VARARGS,
+      "stop( Position )              Stop the player" },
+    { "exit", MediaControl_exit, METH_VARARGS,
+      "exit( )                     Exit the player" },
+    { "set_mrl", MediaControl_set_mrl, METH_VARARGS,
+      "set_mrl( str )               Set the file to be played" },
+    { "get_mrl", MediaControl_get_mrl, METH_VARARGS,
+      "get_mrl( ) -> str       Get the played file" },
+    { "snapshot", MediaControl_snapshot, METH_VARARGS,
+      "snapshot( Position ) -> dict        Take a snapshot" },
+    { "display_text", MediaControl_display_text, METH_VARARGS,
+      "display_text( str, Position, Position )    Display a text on the video" },
+    { "get_stream_information", MediaControl_get_stream_information,
+      METH_VARARGS,
+      "get_stream_information( ) -> dict      Get information about the stream"},
+    { "sound_get_volume", MediaControl_sound_get_volume, METH_VARARGS,
+      "sound_get_volume( ) -> int       Get the volume" },
+    { "sound_set_volume", MediaControl_sound_set_volume, METH_VARARGS,
+      "sound_set_volume( int )           Set the volume" },
+    { "set_visual", MediaControl_set_visual, METH_VARARGS,
+      "set_visual( int )           Set the embedding window visual ID" },
+    { "get_rate", MediaControl_get_rate, METH_VARARGS,
+      "get_rate( ) -> int       Get the rate" },
+    { "set_rate", MediaControl_set_rate, METH_VARARGS,
+      "set_rate( int )              Set the rate" },
+    { "get_fullscreen", MediaControl_get_fullscreen, METH_VARARGS,
+      "get_fullscreen( ) -> int       Get the fullscreen status" },
+    { "set_fullscreen", MediaControl_set_fullscreen, METH_VARARGS,
+      "set_fullscreen( int )              Set the fullscreen status" },
+     { "set_raw_callbacks", MediaControl_set_raw_callbacks, METH_VARARGS,
+        "set_raw_callbacks(read_cbk, seek_cbk, fsize, id)     Set the callbacks for the raw access method" }, /* added by Ivaylo */
+    { NULL, NULL, 0, NULL },
+};
+
+static PyTypeObject MediaControl_Type =
+{
+    PyObject_HEAD_INIT( NULL )
+    0,                         /*ob_size*/
+    "vlc.MediaControl",        /*tp_name*/
+    sizeof( MediaControl_Type ), /*tp_basicsize*/
+    0,                         /*tp_itemsize*/
+    ( destructor )MediaControl_dealloc,      /*tp_dealloc*/
+    0,                         /*tp_print*/
+    0,                         /*tp_getattr*/
+    0,                         /*tp_setattr*/
+    0,                         /*tp_compare*/
+    0,                         /*tp_repr*/
+    0,                         /*tp_as_number*/
+    0,                         /*tp_as_sequence*/
+    0,                         /*tp_as_mapping*/
+    0,                         /*tp_hash */
+    0,                         /*tp_call*/
+    0,                         /*tp_str*/
+    0,                         /*tp_getattro*/
+    0,                         /*tp_setattro*/
+    0,                         /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
+    "Control of a VLC instance.\n\nvlc.MediaControl(args): initialisation with a list of VLC parameters.\nvlc.MediaControl(instance): initialisation with an existing vlc.Instance",  /* tp_doc */
+    0,                     /* tp_traverse */
+    0,                     /* tp_clear */
+    0,                     /* tp_richcompare */
+    0,                     /* tp_weaklistoffset */
+    0,                     /* tp_iter */
+    0,                     /* tp_iternext */
+    MediaControl_methods,             /* tp_methods */
+    0,             /* tp_members */
+    0,                         /* tp_getset */
+    0,                         /* tp_base */
+    0,                         /* tp_dict */
+    0,                         /* tp_descr_get */
+    0,                         /* tp_descr_set */
+    0,                         /* tp_dictoffset */
+    0,                         /* tp_init */
+    0,                         /* tp_alloc */
+    MediaControl_new,          /* tp_new */
+};
Index: bindings/python/GIT-VERSION
===================================================================
--- bindings/python/GIT-VERSION	(.../trunk)	(revision 0)
+++ bindings/python/GIT-VERSION	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,3 @@
+commit 2eeddcf4ae267ad5b2bbac5d518a69c51104cf68
+Author: Rmi Duraffort <ivoire@videolan.org>
+Date:   Tue Aug 25 12:28:49 2009 +0200
Index: bindings/python/setup.py
===================================================================
--- bindings/python/setup.py	(.../trunk)	(revision 0)
+++ bindings/python/setup.py	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,134 @@
+from distutils.core import setup, Extension
+import os
+import commands
+
+# Get build variables (buildir, srcdir)
+top_builddir = os.path.join( '..', '..' )
+os.environ['top_builddir'] = top_builddir
+
+# Determine the extra link args. Normally, vlc-config should take care
+# of this and return the right path values, from a development tree or
+# an installed version.
+libtool=False
+linkargs=[]
+d=os.path.join(top_builddir, 'src', '.libs')
+if os.path.exists(d):
+    # We are in a development tree, which was compiled with libtool
+    libtool=True
+    linkargs=[ '-L' + d ]
+else:
+    d=os.path.join(top_builddir, 'src')
+    # We are in a development tree, which was compiled without libtool
+    if os.path.exists(d):
+        linkargs=[ '-L' + d ]
+
+# For out-of-tree compilations
+srcdir = '.'
+
+def get_vlcconfig():
+    vlcconfig=None
+    for n in ( 'vlc-config',
+               os.path.join( top_builddir, 'vlc-config' )):
+        if os.path.exists(n):
+            vlcconfig=n
+            break
+    status, output = commands.getstatusoutput('pkg-config libvlc --exists')
+    if status == 0:
+        vlcconfig="pkg-config libvlc"
+    if vlcconfig is None:
+        print "*** Warning *** Cannot find vlc-config. Will try sane defaults."
+    elif os.sys.platform == 'win32':
+        # Win32 does not know how to invoke the shell itself.
+        vlcconfig="sh %s" % vlcconfig
+    return vlcconfig
+
+def get_vlc_version():
+    vlcconfig=get_vlcconfig()
+    if vlcconfig is None:
+        return ""
+    else:
+        version=os.popen('%s --modversion' % vlcconfig, 'r').readline().strip()
+        return version
+
+def get_cflags():
+    vlcconfig=get_vlcconfig()
+    if vlcconfig is None:
+        return []
+    else:
+        cflags=os.popen('%s --cflags ' % vlcconfig, 'r').readline().strip()
+        return cflags
+
+def get_ldflags():
+    vlcconfig=get_vlcconfig()
+    if vlcconfig is None:
+        return [ '-lvlc' ]
+    else:
+	ldflags = []
+	if os.sys.platform == 'darwin':
+	    ldflags = "-read_only_relocs warning".split()
+        ldflags.extend(os.popen('%s --libs ' % vlcconfig,
+                                'r').readline().rstrip().split())
+	if os.sys.platform == 'darwin':
+	    ldflags.append('-lstdc++')
+        return ldflags
+
+#source_files = [ 'vlc_module.c', 'vlc_mediacontrol.c',
+#                 'vlc_position.c', 'vlc_instance.c', 'vlc_input.c' ]
+source_files = [ 'vlc_module.c' ]
+
+# To compile in a local vlc tree
+vlclocal = Extension('vlc',
+                     sources = [ os.path.join( srcdir, f ) for f in source_files ],
+                     include_dirs = [ top_builddir, os.path.join(top_builddir,"include"),
+                                      srcdir ],
+                     extra_objects = [ ],
+                     extra_compile_args = get_cflags(),
+                     extra_link_args = linkargs + get_ldflags(),
+                     )
+
+setup (name = 'python-vlc',
+       version = '1.0.0.90',
+       author='Olivier Aubert',
+       author_email='olivier.aubert@liris.cnrs.fr',
+       url='http://wiki.videolan.org/PythonBinding',
+       py_modules=['vlcwidget'],
+       keywords = [ 'vlc', 'video' ],
+       license = "GPL",
+       description = "VLC bindings for python.",
+       long_description = """VLC bindings for python.
+
+This module provides bindings for the native libvlc API of the VLC
+video player. Documentation can be found on the VLC wiki :
+http://wiki.videolan.org/ExternalAPI
+
+This module also provides a MediaControl object, which implements an
+API inspired from the OMG Audio/Video Stream 1.0 specification.
+Documentation can be found on the VLC wiki :
+http://wiki.videolan.org/PythonBinding
+
+Example session (for the MediaControl API):
+
+import vlc
+mc=vlc.MediaControl(['--verbose', '1'])
+mc.playlist_add_item('movie.mpg')
+
+# Start the movie at 2000ms
+p=vlc.Position()
+p.origin=vlc.RelativePosition
+p.key=vlc.MediaTime
+p.value=2000
+mc.start(p)
+# which could be abbreviated as
+# mc.start(2000)
+# for the default conversion from int is to make a RelativePosition in MediaTime
+
+# Display some text during 2000ms
+mc.display_text('Some useless information', 0, 2000)
+
+# Pause the video
+mc.pause(0)
+
+# Get status information
+mc.get_stream_information()
+       """,
+       ext_modules = [ vlclocal ])
Index: bindings/python/vlcglue.h
===================================================================
--- bindings/python/vlcglue.h	(.../trunk)	(revision 0)
+++ bindings/python/vlcglue.h	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,162 @@
+/*****************************************************************************
+ * vlcglue.h: Main header for the Python binding
+ *****************************************************************************
+ * Copyright (C) 1998-2004 the VideoLAN team
+ * $Id$
+ *
+ * Authors: Olivier Aubert <olivier.aubert at liris.cnrs.fr>
+ *          Clment Stenac <zorglub@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+#ifndef _VLCGLUE_H
+#define _VLCGLUE_H 1
+
+#include <Python.h>
+#include "structmember.h"
+
+#include <stdio.h>
+#include <vlc/vlc.h>
+#include <vlc/libvlc.h>
+#include <vlc/mediacontrol_structures.h>
+#include <vlc/mediacontrol.h>
+
+/* Python 2.5 64-bit support compatibility define */
+#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
+typedef int Py_ssize_t;
+#define PY_SSIZE_T_MAX INT_MAX
+#define PY_SSIZE_T_MIN INT_MIN
+#endif
+
+
+/**********************************************************************
+ * Exceptions handling
+ **********************************************************************/
+
+#define MC_TRY exception=mediacontrol_exception_create( )
+
+#define MC_EXCEPT  \
+  if( exception && exception->code ) { \
+    PyObject *py_exc = MediaControl_InternalException; \
+    switch( exception->code ) { \
+    case mediacontrol_InternalException: \
+      py_exc = MediaControl_InternalException; \
+      break; \
+    case mediacontrol_PlaylistException: \
+      py_exc = MediaControl_PlaylistException; \
+      break; \
+    case mediacontrol_InvalidPosition: \
+      py_exc = MediaControl_InvalidPosition; \
+      break; \
+    case mediacontrol_PositionKeyNotSupported: \
+      py_exc = MediaControl_PositionKeyNotSupported; \
+      break; \
+    case mediacontrol_PositionOriginNotSupported: \
+      py_exc = MediaControl_PositionOriginNotSupported; \
+      break; \
+    } \
+    PyErr_SetString( py_exc, exception->message ); \
+    mediacontrol_exception_free( exception ); \
+    return NULL; \
+  } else if( exception ) { mediacontrol_exception_free( exception ); }
+
+PyObject *MediaControl_InternalException;
+PyObject *MediaControl_PositionKeyNotSupported;
+PyObject *MediaControl_PositionOriginNotSupported;
+PyObject *MediaControl_InvalidPosition;
+PyObject *MediaControl_PlaylistException;
+PyObject *vlc_Exception;
+
+/**********************************************************************
+ * vlc.Instance Object
+ **********************************************************************/
+typedef struct
+{
+    PyObject_HEAD
+    libvlc_instance_t* p_instance;
+} vlcInstance;
+
+/**********************************************************************
+ * MediaControl Object
+ **********************************************************************/
+typedef struct
+{
+    PyObject_HEAD
+    mediacontrol_Instance* mc;
+    vlcInstance *vlc_instance;
+} MediaControl;
+
+/**********************************************************************
+ * Position Object
+ **********************************************************************/
+typedef struct
+{
+    PyObject_HEAD
+    int origin;
+    int key;
+    PY_LONG_LONG value;
+} PyPosition;
+
+/**********************************************************************
+ * vlc.MediaPlayer Object
+ **********************************************************************/
+typedef struct
+{
+    PyObject_HEAD
+    libvlc_media_player_t* p_mp;
+} vlcMediaPlayer;
+
+/**********************************************************************
+ * vlc.Media Object
+ **********************************************************************/
+typedef struct
+{
+    PyObject_HEAD
+    libvlc_media_t* p_media;
+} vlcMedia;
+
+/* Forward declarations */
+staticforward PyTypeObject MediaControl_Type;
+staticforward PyTypeObject PyPosition_Type;
+staticforward PyTypeObject vlcInstance_Type;
+staticforward PyTypeObject vlcMediaPlayer_Type;
+staticforward PyTypeObject vlcMedia_Type;
+
+#define LIBVLC_INSTANCE(self) (((vlcInstance*)self)->p_instance)
+#define LIBVLC_MEDIAPLAYER(self) (((vlcMediaPlayer*)self)->p_mp)
+#define LIBVLC_MEDIA(self) (((vlcMedia*)self)->p_media)
+#define LIBVLC_MC(self) (((MediaControl*)self)->mc)
+
+#define LIBVLC_TRY libvlc_exception_init( &ex );
+
+#define LIBVLC_EXCEPT if( libvlc_exception_raised( &ex ) ) { \
+    PyObject *py_exc = vlc_Exception; \
+    PyErr_SetString( py_exc, libvlc_exception_get_message( &ex ) ); \
+    return NULL; \
+  }
+
+mediacontrol_PositionKey positionKey_py_to_c( PyObject * py_key );
+mediacontrol_PositionOrigin positionOrigin_py_to_c( PyObject * py_origin );
+mediacontrol_Position * position_py_to_c( PyObject * py_position );
+PyPosition * position_c_to_py( mediacontrol_Position * position );
+
+/* Long long conversion on Mac os X/ppc */
+#if defined (__ppc__) || defined(__ppc64__)
+#define ntohll(x) ((long long) x >> 64)
+#else
+#define ntohll(x) (x)
+#endif
+
+#endif
Index: bindings/python/vlc_instance.c
===================================================================
--- bindings/python/vlc_instance.c	(.../trunk)	(revision 0)
+++ bindings/python/vlc_instance.c	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,611 @@
+/*****************************************************************************
+ * vlc_instance.c: vlc.Instance binding
+ *****************************************************************************
+ * Copyright (C) 2006,2007,2008,2009 the VideoLAN team
+ * $Id$
+ *
+ * Authors: Olivier Aubert <olivier.aubert at liris.cnrs.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+#include "vlcglue.h"
+
+/* Helper functions */
+static Py_ssize_t
+pyoptions_to_args(PyObject *py_options, char*** pppsz_args)
+{
+    Py_ssize_t i_size;
+    Py_ssize_t  i_index;
+
+    Py_INCREF( py_options );
+    if( ! PySequence_Check( py_options ) )
+    {
+        PyErr_SetString( PyExc_TypeError, "Parameter must be a sequence." );
+        return -1;
+    }
+    i_size = PySequence_Size( py_options );
+
+    char **ppsz_args = *pppsz_args = malloc( ( i_size + 1 ) * sizeof( char * ) );
+
+    if( ! ppsz_args )
+    {
+        PyErr_SetString( PyExc_MemoryError, "Out of memory" );
+        return -1;
+    }
+
+    for ( i_index = 0; i_index < i_size; i_index++ )
+    {
+        ppsz_args[i_index] =
+            strdup( PyString_AsString( PyObject_Str(
+                                           PySequence_GetItem( py_options,
+                                                               i_index ) ) ) );
+    }
+    ppsz_args[i_size] = NULL;
+    Py_DECREF( py_options );
+    return i_size;
+}
+
+static void
+free_args(int i_size, char** ppsz_args)
+{
+    int i_index;
+
+    for ( i_index = 0; i_index < i_size; i_index++ )
+        free( ppsz_args[i_index] );
+    free( ppsz_args );
+}
+
+/*****************************************************************************
+ * Instance object implementation
+ *****************************************************************************/
+
+static PyObject *
+vlcInstance_new( PyTypeObject *type, PyObject *args, PyObject *kwds )
+{
+    vlcInstance *self;
+    libvlc_exception_t ex;
+    PyObject* py_list = NULL;
+    char** ppsz_args = NULL;
+    int i_size = 0;
+
+    fprintf(stderr, "Instantiating\n");
+    if( PyArg_ParseTuple( args, "|O", &py_list ) )
+    {
+        i_size = pyoptions_to_args( py_list, &ppsz_args );
+        if( i_size < 0 )
+            return NULL;
+    }
+    else
+    {
+        /* No arguments were given. Clear the exception raised
+           by PyArg_ParseTuple. */
+        PyErr_Clear( );
+    }
+
+    self = PyObject_New( vlcInstance, &vlcInstance_Type );
+
+    Py_BEGIN_ALLOW_THREADS
+    LIBVLC_TRY
+    LIBVLC_INSTANCE(self) = libvlc_new( i_size, ppsz_args, &ex );
+    free_args( i_size, ppsz_args );
+    LIBVLC_EXCEPT
+    Py_END_ALLOW_THREADS
+
+    Py_INCREF( self );
+    return ( PyObject * )self;
+}
+
+static void
+vlcInstance_dealloc( PyObject *self )
+{
+    libvlc_release( LIBVLC_INSTANCE(self) );
+    PyObject_DEL( self );
+}
+
+static PyObject *
+vlcInstance_get_vlc_id( PyObject *self, PyObject *args )
+{
+    return Py_BuildValue( "i", libvlc_get_vlc_id( LIBVLC_INSTANCE(self) ) );
+}
+
+static PyObject *
+vlcInstance_new_media_player( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    libvlc_media_player_t *p_mp;
+    vlcMediaPlayer *p_ret;
+
+    LIBVLC_TRY;
+    p_mp = libvlc_media_player_new( LIBVLC_INSTANCE(self), &ex );
+    LIBVLC_EXCEPT;
+
+    p_ret = PyObject_New( vlcMediaPlayer, &vlcMediaPlayer_Type );
+    p_ret->p_mp = p_mp;
+    Py_INCREF( p_ret ); /* Ah bon ? */
+    return ( PyObject * )p_ret;
+}
+
+static PyObject *
+vlcInstance_audio_toggle_mute( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    LIBVLC_TRY;
+    libvlc_audio_toggle_mute( LIBVLC_INSTANCE(self), &ex );
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_audio_get_mute( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+
+    LIBVLC_TRY;
+    i_ret = libvlc_audio_get_mute( LIBVLC_INSTANCE(self), &ex );
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcInstance_audio_set_mute( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_mute;
+
+    if( !PyArg_ParseTuple( args, "i", &i_mute ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_audio_set_mute( LIBVLC_INSTANCE(self), i_mute, &ex );
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_audio_get_volume( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+
+    LIBVLC_TRY;
+    i_ret = libvlc_audio_get_volume( LIBVLC_INSTANCE(self), &ex );
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcInstance_audio_set_volume( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_volume;
+
+    if( !PyArg_ParseTuple( args, "i", &i_volume ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_audio_set_volume( LIBVLC_INSTANCE(self), i_volume, &ex );
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_audio_get_channel( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+
+    LIBVLC_TRY;
+    i_ret = libvlc_audio_get_channel( LIBVLC_INSTANCE(self), &ex );
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcInstance_audio_set_channel( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_channel;
+
+    if( !PyArg_ParseTuple( args, "i", &i_channel ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_audio_set_channel( LIBVLC_INSTANCE(self), i_channel, &ex );
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+/* vlm_add_broadcast : name, input MRL, output MRL
+   Keywords: options, enable, loop */
+static PyObject *
+vlcInstance_vlm_add_broadcast( PyObject *self, PyObject *args, PyObject *kwds )
+{
+    libvlc_exception_t ex;
+    static char *kwlist[] = { "name", "input", "output",
+                              "options", "enable", "loop", NULL};
+    char* psz_name = NULL;
+    char* psz_input = NULL;
+    char* psz_output = NULL;
+    PyObject* py_options = NULL;
+    int i_enable = 1;
+    int i_loop = 0;
+    int i_size = 0;
+    char** ppsz_args = NULL;
+
+    if( !PyArg_ParseTupleAndKeywords( args, kwds, "sss|Oii", kwlist,
+                                      &psz_name,
+                      &psz_input, &psz_output,
+                      &py_options, &i_enable, &i_loop ) )
+        return NULL;
+
+    if( py_options )
+    {
+        i_size = pyoptions_to_args( py_options, &ppsz_args );
+    }
+
+    LIBVLC_TRY;
+    libvlc_vlm_add_broadcast( LIBVLC_INSTANCE(self),
+                              psz_name, psz_input, psz_output,
+                              i_size, ppsz_args, i_enable, i_loop, &ex);
+    free_args( i_size, ppsz_args );
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_del_media( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_name ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_del_media( LIBVLC_INSTANCE(self), psz_name, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_set_enabled( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+    int i_enabled;
+
+    if( !PyArg_ParseTuple( args, "si", &psz_name, &i_enabled ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_set_enabled( LIBVLC_INSTANCE(self), psz_name, i_enabled, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_set_output( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+    char* psz_output;
+
+    if( !PyArg_ParseTuple( args, "ss", &psz_name, &psz_output ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_set_output( LIBVLC_INSTANCE(self), psz_name, psz_output, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_set_input( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+    char* psz_input;
+
+    if( !PyArg_ParseTuple( args, "ss", &psz_name, &psz_input ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_set_input( LIBVLC_INSTANCE(self), psz_name, psz_input, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_add_input( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+    char* psz_input;
+
+    if( !PyArg_ParseTuple( args, "ss", &psz_name, &psz_input ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_add_input( LIBVLC_INSTANCE(self), psz_name, psz_input, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_set_loop( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+    int i_loop;
+
+    if( !PyArg_ParseTuple( args, "si", &psz_name, &i_loop ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_set_loop( LIBVLC_INSTANCE(self), psz_name, i_loop, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_change_media( PyObject *self, PyObject *args, PyObject *kwds )
+{
+    libvlc_exception_t ex;
+    static char *kwlist[] = { "name", "input", "output",
+                              "options", "enable", "loop", NULL};
+    char* psz_name = NULL;
+    char* psz_input = NULL;
+    char* psz_output = NULL;
+    PyObject* py_options = NULL;
+    int i_enable = 1;
+    int i_loop = 0;
+    int i_size = 0;
+    char** ppsz_args = NULL;
+
+    if( !PyArg_ParseTupleAndKeywords( args, kwds, "sss|Oii", kwlist,
+                                      &psz_name,
+                      &psz_input, &psz_output,
+                      &py_options, &i_enable, &i_loop ) )
+        return NULL;
+
+    if( py_options )
+    {
+        i_size = pyoptions_to_args( py_options, &ppsz_args );
+    }
+
+    LIBVLC_TRY;
+    libvlc_vlm_change_media( LIBVLC_INSTANCE(self),
+                              psz_name, psz_input, psz_output,
+                              i_size, ppsz_args, i_enable, i_loop, &ex);
+    free_args( i_size, ppsz_args );
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_play_media( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_name ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_play_media( LIBVLC_INSTANCE(self), psz_name, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_stop_media( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_name ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_stop_media( LIBVLC_INSTANCE(self), psz_name, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_pause_media( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_name ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_pause_media( LIBVLC_INSTANCE(self), psz_name, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_seek_media( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+    float f_percentage;
+
+    if( !PyArg_ParseTuple( args, "sf", &psz_name, &f_percentage ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_seek_media( LIBVLC_INSTANCE(self), psz_name, f_percentage, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_show_media( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+    char* psz_ret;
+    PyObject* o_ret;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_name ) )
+        return NULL;
+    LIBVLC_TRY;
+    psz_ret = libvlc_vlm_show_media( LIBVLC_INSTANCE(self), psz_name, &ex );
+    LIBVLC_EXCEPT;
+    o_ret = Py_BuildValue( "s", psz_ret );
+    free( psz_ret );
+    return o_ret;
+}
+
+static PyObject *
+vlcInstance_media_new( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    libvlc_media_t *p_media;
+    char* psz_mrl = NULL;
+    vlcMedia *p_ret;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_mrl ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    p_media = libvlc_media_new( LIBVLC_INSTANCE(self), psz_mrl, &ex );
+    LIBVLC_EXCEPT;
+
+    p_ret = PyObject_New( vlcMedia, &vlcMedia_Type );
+    p_ret->p_media = p_media;
+    Py_INCREF( p_ret ); /* Ah bon ? */
+    return ( PyObject * )p_ret;
+}
+
+/* Method table */
+static PyMethodDef vlcInstance_methods[] =
+{
+    { "get_vlc_id", vlcInstance_get_vlc_id, METH_NOARGS,
+      "get_vlc_id( ) -> int        Get the instance id."},
+    { "audio_toggle_mute", vlcInstance_audio_toggle_mute, METH_NOARGS,
+      "audio_toggle_mute()         Toggle the mute state"},
+    { "audio_get_mute", vlcInstance_audio_get_mute, METH_NOARGS,
+      "audio_get_mute() -> int     Get the mute state"},
+    { "audio_set_mute", vlcInstance_audio_set_mute, METH_VARARGS,
+      "audio_set_mute(state=int)         Set the mute state"},
+    { "audio_get_volume", vlcInstance_audio_get_volume, METH_NOARGS,
+      "audio_get_volume() -> int   Get the audio volume"},
+    { "audio_set_volume", vlcInstance_audio_set_volume, METH_VARARGS,
+      "audio_set_volume(volume=int)       Set the audio volume"},
+    { "audio_get_channel", vlcInstance_audio_get_channel, METH_NOARGS,
+      "audio_get_channel() -> int  Get current audio channel" },
+    { "audio_set_channel", vlcInstance_audio_set_channel, METH_VARARGS,
+      "audio_set_channel(int)      Set current audio channel" },
+
+    { "media_new", vlcInstance_media_new, METH_VARARGS,
+      "media_new(str) -> object   Create a media object with the given mrl."},
+
+    { "mediaplayer_new", vlcInstance_new_media_player, METH_NOARGS,
+      "mediaplayer_new() -> object   Create a media player."},
+
+    { "vlm_add_broadcast", vlcInstance_vlm_add_broadcast, METH_VARARGS | METH_KEYWORDS,
+      "vlm_add_broadcast(name=str, input=str, output=str, options=list, enable=int, loop=int)   Add a new broadcast" },
+    { "vlm_del_media", vlcInstance_vlm_del_media, METH_VARARGS,
+      "vlm_del_media(name=str)    Delete a media" },
+    { "vlm_set_enabled", vlcInstance_vlm_set_enabled, METH_VARARGS,
+      "vlm_set_enabled(name=str, enabled=int)    Enable/disable a media" },
+    { "vlm_set_output", vlcInstance_vlm_set_output, METH_VARARGS,
+      "vlm_set_output(name=str, output=str)      Set the output" },
+    { "vlm_set_input", vlcInstance_vlm_set_input, METH_VARARGS,
+      "vlm_set_input(name=str, output=str)       Set the input" },
+    { "vlm_add_input", vlcInstance_vlm_add_input, METH_VARARGS,
+      "vlm_add_input(name=str, output=str)       Add a media's input MRL" },
+    { "vlm_set_loop", vlcInstance_vlm_set_loop, METH_VARARGS,
+      "vlm_set_loop(name=str, loop=int)          Change the looping value" },
+    { "vlm_change_media", vlcInstance_vlm_change_media, METH_VARARGS | METH_KEYWORDS,
+      "vlm_change_media(name=str, input=str, output=str, options=list, enable=int, loop=int)   Change the broadcast parameters" },
+    { "vlm_play_media", vlcInstance_vlm_play_media, METH_VARARGS,
+      "vlm_play_media(name=str)       Plays the named broadcast." },
+    { "vlm_stop_media", vlcInstance_vlm_stop_media, METH_VARARGS,
+      "vlm_stop_media(name=str)       Stops the named broadcast." },
+    { "vlm_pause_media", vlcInstance_vlm_pause_media, METH_VARARGS,
+      "vlm_pause_media(name=str)      Pauses the named broadcast." },
+    { "vlm_seek_media", vlcInstance_vlm_seek_media, METH_VARARGS,
+      "vlm_seek_media(name=str, percentage=float)  Seeks in the named broadcast." },
+    { "vlm_show_media", vlcInstance_vlm_show_media, METH_VARARGS,
+      "vlm_show_media(name=str)       Return information of the named broadcast." },
+
+    { NULL, NULL, 0, NULL },
+};
+
+static PyTypeObject vlcInstance_Type =
+{
+    PyObject_HEAD_INIT( NULL )
+    0,                          /*ob_size*/
+    "vlc.Instance",             /*tp_name*/
+    sizeof( vlcInstance_Type ), /*tp_basicsize*/
+    0,                          /*tp_itemsize*/
+    ( destructor )vlcInstance_dealloc,      /*tp_dealloc*/
+    0,                         /*tp_print*/
+    0,                         /*tp_getattr*/
+    0,                         /*tp_setattr*/
+    0,                         /*tp_compare*/
+    0,                         /*tp_repr*/
+    0,                         /*tp_as_number*/
+    0,                         /*tp_as_sequence*/
+    0,                         /*tp_as_mapping*/
+    0,                         /*tp_hash */
+    0,                         /*tp_call*/
+    0,                         /*tp_str*/
+    0,                         /*tp_getattro*/
+    0,                         /*tp_setattro*/
+    0,                         /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
+    "VLC Instance(args)",  /* tp_doc */
+    0,                     /* tp_traverse */
+    0,                     /* tp_clear */
+    0,                     /* tp_richcompare */
+    0,                     /* tp_weaklistoffset */
+    0,                     /* tp_iter */
+    0,                     /* tp_iternext */
+    vlcInstance_methods,             /* tp_methods */
+    0,             /* tp_members */
+    0,                         /* tp_getset */
+    0,                         /* tp_base */
+    0,                         /* tp_dict */
+    0,                         /* tp_descr_get */
+    0,                         /* tp_descr_set */
+    0,                         /* tp_dictoffset */
+    0,                         /* tp_init */
+    0,                         /* tp_alloc */
+    vlcInstance_new,          /* tp_new */
+};
Index: bindings/python/vlc_position.c
===================================================================
--- bindings/python/vlc_position.c	(.../trunk)	(revision 0)
+++ bindings/python/vlc_position.c	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,219 @@
+/*****************************************************************************
+ * vlc_position.c: vlc.Position binding
+ *****************************************************************************
+ * Copyright (C) 2006,2007,2008,2009 the VideoLAN team
+ * $Id$
+ *
+ * Authors: Olivier Aubert <olivier.aubert at liris.cnrs.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+#include "vlcglue.h"
+
+/***********************************************************************
+ * Position
+ ***********************************************************************/
+
+static PyObject *
+PyPosition_new( PyTypeObject *type, PyObject *args, PyObject *kwds )
+{
+    PyPosition *self;
+    static char *kwlist[] = { "value", "origin", "key", NULL};
+
+    self = PyObject_New( PyPosition, &PyPosition_Type );
+
+    self->value=0;
+    self->origin=mediacontrol_AbsolutePosition;
+    self->key=mediacontrol_MediaTime;
+
+    if(! PyArg_ParseTupleAndKeywords( args, kwds, "|lii", kwlist,
+                                      &(self->value),
+                                      &(self->origin),
+                                      &(self->key) ) )
+    {
+        return NULL;
+    }
+
+    if( self->key != mediacontrol_MediaTime
+    && self->key != mediacontrol_ByteCount
+    && self->key != mediacontrol_SampleCount )
+    {
+        PyErr_SetString ( MediaControl_InternalException, "Invalid key value" );
+        return NULL;
+    }
+
+    if( self->origin != mediacontrol_AbsolutePosition
+    && self->origin != mediacontrol_RelativePosition
+    && self->origin != mediacontrol_ModuloPosition )
+    {
+        PyErr_SetString ( MediaControl_InternalException, "Invalid origin value" );
+        return NULL;
+    }
+
+    Py_INCREF( self );
+    return ( PyObject * )self;
+}
+
+mediacontrol_PositionKey
+positionKey_py_to_c( PyObject * py_key )
+{
+    mediacontrol_PositionKey key_position = mediacontrol_MediaTime;
+    int key;
+
+    if( !PyArg_Parse( py_key, "i", &key ) )
+    {
+        PyErr_SetString ( MediaControl_InternalException, "Invalid key value" );
+        return key_position;
+    }
+
+    switch ( key )
+    {
+    case 0: key = mediacontrol_ByteCount;   break;
+    case 1: key = mediacontrol_SampleCount; break;
+    case 2: key = mediacontrol_MediaTime;   break;
+    }
+    return key_position;
+}
+
+mediacontrol_PositionOrigin
+positionOrigin_py_to_c( PyObject * py_origin )
+{
+    mediacontrol_PositionOrigin  origin_position = mediacontrol_AbsolutePosition;
+    int origin;
+
+    if( !PyArg_Parse( py_origin,"i", &origin ) )
+    {
+        PyErr_SetString( MediaControl_InternalException,
+                         "Invalid origin value" );
+        return origin_position;
+    }
+
+    switch ( origin )
+    {
+    case 0: origin_position = mediacontrol_AbsolutePosition; break;
+    case 1: origin_position = mediacontrol_RelativePosition; break;
+    case 2: origin_position = mediacontrol_ModuloPosition;   break;
+    }
+
+    return origin_position;
+}
+
+/* Methods for transforming the Position Python object to Position structure*/
+mediacontrol_Position*
+position_py_to_c( PyObject * py_position )
+{
+    mediacontrol_Position * a_position = NULL;
+    PyPosition *pos = ( PyPosition* )py_position;
+
+    a_position = ( mediacontrol_Position* )malloc( sizeof( mediacontrol_Position ) );
+    if( !a_position )
+    {
+        PyErr_SetString( PyExc_MemoryError, "Out of memory" );
+        return NULL;
+    }
+
+    if( !py_position )
+    {
+        /* If we give a NULL value, it will be considered as
+           a 0 relative position in mediatime */
+        a_position->origin = mediacontrol_RelativePosition;
+        a_position->key    = mediacontrol_MediaTime;
+        a_position->value  = 0;
+    }
+    else if( PyObject_IsInstance( py_position, ( PyObject* )&PyPosition_Type ) )
+    {
+        a_position->origin = pos->origin;
+        a_position->key    = pos->key;
+        a_position->value  = ntohll(pos->value);
+    }
+    else
+    {
+        /* Feature: if we give an integer, it will be considered as
+           a relative position in mediatime */
+        a_position->origin = mediacontrol_RelativePosition;
+        a_position->key    = mediacontrol_MediaTime;
+        a_position->value  = PyLong_AsLongLong( py_position );
+    }
+    return a_position;
+}
+
+PyPosition*
+position_c_to_py( mediacontrol_Position *position )
+{
+    PyPosition* py_retval;
+
+    py_retval = PyObject_New( PyPosition, &PyPosition_Type );
+    py_retval->origin = position->origin;
+    py_retval->key    = position->key;
+    py_retval->value  = position->value;
+
+    return py_retval;
+}
+
+static PyMethodDef PyPosition_methods[] =
+{
+    { NULL }  /* Sentinel */
+};
+
+static PyMemberDef PyPosition_members[] =
+{
+    { "origin", T_INT, offsetof( PyPosition, origin ), 0, "Position origin" },
+    { "key",    T_INT, offsetof( PyPosition, key ),    0, "Position key" },
+    { "value",  T_ULONG, offsetof( PyPosition, value ), 0, "Position value" },
+    { NULL }  /* Sentinel */
+};
+
+static PyTypeObject PyPosition_Type =
+{
+    PyObject_HEAD_INIT( NULL )
+    0,                         /*ob_size*/
+    "vlc.Position",            /*tp_name*/
+    sizeof( PyPosition_Type ),   /*tp_basicsize*/
+    0,                         /*tp_itemsize*/
+    0,                         /*tp_dealloc*/
+    0,                         /*tp_print*/
+    0,                         /*tp_getattr*/
+    0,                         /*tp_setattr*/
+    0,                         /*tp_compare*/
+    0,                         /*tp_repr*/
+    0,                         /*tp_as_number*/
+    0,                         /*tp_as_sequence*/
+    0,                         /*tp_as_mapping*/
+    0,                         /*tp_hash */
+    0,                         /*tp_call*/
+    0,                         /*tp_str*/
+    0,                         /*tp_getattro*/
+    0,                         /*tp_setattro*/
+    0,                         /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
+    "Represent a Position with value, origin and key",  /* tp_doc */
+    0,                        /* tp_traverse */
+    0,                        /* tp_clear */
+    0,                         /* tp_richcompare */
+    0,                         /* tp_weaklistoffset */
+    0,                         /* tp_iter */
+    0,                          /* tp_iternext */
+    PyPosition_methods,             /* tp_methods */
+    PyPosition_members,             /* tp_members */
+    0,                         /* tp_getset */
+    0,                         /* tp_base */
+    0,                         /* tp_dict */
+    0,                         /* tp_descr_get */
+    0,                         /* tp_descr_set */
+    0,                         /* tp_dictoffset */
+    0,                         /* tp_init */
+    0,                         /* tp_alloc */
+    PyPosition_new,            /* tp_new */
+};
Index: bindings/python/vlc_module.c
===================================================================
--- bindings/python/vlc_module.c	(.../trunk)	(revision 0)
+++ bindings/python/vlc_module.c	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,179 @@
+/*****************************************************************************
+ * vlc_module.c: vlc python binding module
+ *****************************************************************************
+ * Copyright (C) 2006,2007,2008,2009 the VideoLAN team
+ * $Id$
+ *
+ * Authors: Olivier Aubert <olivier.aubert at liris.cnrs.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include "vlcglue.h"
+
+/**************************************************************************
+ * VLC Module
+ **************************************************************************/
+
+#ifndef vlcMODINIT_FUNC /* declarations for DLL import/export */
+#define vlcMODINIT_FUNC void
+#endif
+
+static PyMethodDef vlc_methods[] = {
+    { NULL }  /* Sentinel */
+};
+
+/* Module globals */
+PyObject* MediaControl_InternalException          = NULL;
+PyObject* MediaControl_PositionKeyNotSupported    = NULL;
+PyObject *MediaControl_PositionOriginNotSupported = NULL;
+PyObject* MediaControl_InvalidPosition            = NULL;
+PyObject *MediaControl_PlaylistException          = NULL;
+
+/* Added by Ivaylo */
+static PyObject* py_read_callback     = NULL;
+static PyObject* py_seek_callback     = NULL;
+/* End added by Ivaylo */
+
+
+vlcMODINIT_FUNC
+initvlc( void )
+{
+    PyObject* p_module;
+
+    /* vlcMediaPlayer_Type.tp_new = PyType_GenericNew; */
+    vlcMediaPlayer_Type.tp_alloc = PyType_GenericAlloc;
+    /* vlcMedia_Type.tp_new = PyType_GenericNew; */
+    vlcMedia_Type.tp_alloc = PyType_GenericAlloc;
+
+    vlcInstance_Type.tp_alloc = PyType_GenericAlloc;
+    MediaControl_Type.tp_alloc = PyType_GenericAlloc;
+
+    p_module = Py_InitModule3( "vlc", vlc_methods,
+                               "VLC media player embedding module." );
+
+    if( !p_module )
+      return;
+
+    if( PyType_Ready( &PyPosition_Type ) < 0 )
+        return;
+    if( PyType_Ready( &MediaControl_Type ) < 0 )
+        return;
+    if( PyType_Ready( &vlcInstance_Type ) < 0 )
+        return;
+    if( PyType_Ready( &vlcMediaPlayer_Type ) < 0 )
+        return;
+    if( PyType_Ready( &vlcMedia_Type ) < 0 )
+        return;
+
+    /* Exceptions */
+    MediaControl_InternalException =
+            PyErr_NewException( "vlc.InternalException", NULL, NULL );
+    Py_INCREF( MediaControl_InternalException );
+    PyModule_AddObject( p_module, "InternalException",
+                        MediaControl_InternalException );
+
+    MediaControl_PositionKeyNotSupported =
+            PyErr_NewException( "vlc.PositionKeyNotSupported", NULL, NULL );
+    Py_INCREF( MediaControl_PositionKeyNotSupported );
+    PyModule_AddObject( p_module, "PositionKeyNotSupported",
+                        MediaControl_PositionKeyNotSupported );
+
+    MediaControl_PositionOriginNotSupported=
+            PyErr_NewException( "vlc.InvalidPosition", NULL, NULL );
+    Py_INCREF( MediaControl_PositionOriginNotSupported );
+    PyModule_AddObject( p_module, "PositionOriginNotSupported",
+                        MediaControl_PositionOriginNotSupported );
+
+    MediaControl_InvalidPosition =
+            PyErr_NewException( "vlc.InvalidPosition", NULL, NULL );
+    Py_INCREF( MediaControl_InvalidPosition );
+    PyModule_AddObject( p_module, "InvalidPosition",
+                        MediaControl_InvalidPosition );
+
+    MediaControl_PlaylistException =
+            PyErr_NewException( "vlc.PlaylistException", NULL, NULL );
+    Py_INCREF( MediaControl_PlaylistException );
+    PyModule_AddObject( p_module, "PlaylistException",
+                        MediaControl_PlaylistException );
+
+    /* Exceptions */
+    vlc_Exception =
+        PyErr_NewException( "vlc.InstanceException", NULL, NULL );
+    Py_INCREF( vlc_Exception );
+    PyModule_AddObject( p_module, "InstanceException",
+                        vlc_Exception );
+
+    /* Types */
+    Py_INCREF( &PyPosition_Type );
+    PyModule_AddObject( p_module, "Position",
+                        ( PyObject * )&PyPosition_Type );
+
+    Py_INCREF( &MediaControl_Type );
+    PyModule_AddObject( p_module, "MediaControl",
+                        ( PyObject * )&MediaControl_Type );
+
+    Py_INCREF( &vlcInstance_Type );
+    PyModule_AddObject( p_module, "Instance",
+                        ( PyObject * )&vlcInstance_Type );
+
+    Py_INCREF( &vlcMediaPlayer_Type );
+    PyModule_AddObject( p_module, "MediaPlayer",
+                        ( PyObject * )&vlcMediaPlayer_Type );
+
+    Py_INCREF( &vlcMedia_Type );
+    PyModule_AddObject( p_module, "Media",
+                        ( PyObject * )&vlcMedia_Type );
+
+    /* Constants */
+    PyModule_AddIntConstant( p_module, "AbsolutePosition",
+                             mediacontrol_AbsolutePosition );
+    PyModule_AddIntConstant( p_module, "RelativePosition",
+                             mediacontrol_RelativePosition );
+    PyModule_AddIntConstant( p_module, "ModuloPosition",
+                             mediacontrol_ModuloPosition );
+
+    PyModule_AddIntConstant( p_module, "ByteCount",
+                             mediacontrol_ByteCount );
+    PyModule_AddIntConstant( p_module, "SampleCount",
+                             mediacontrol_SampleCount );
+    PyModule_AddIntConstant( p_module, "MediaTime",
+                             mediacontrol_MediaTime );
+
+    PyModule_AddIntConstant( p_module, "PlayingStatus",
+                             mediacontrol_PlayingStatus );
+    PyModule_AddIntConstant( p_module, "PauseStatus",
+                             mediacontrol_PauseStatus );
+    PyModule_AddIntConstant( p_module, "InitStatus",
+                             mediacontrol_InitStatus );
+    PyModule_AddIntConstant( p_module, "EndStatus",
+                             mediacontrol_EndStatus );
+    PyModule_AddIntConstant( p_module, "UndefinedStatus",
+                             mediacontrol_UndefinedStatus );
+
+}
+
+/* Horrible hack... Please do not look.  Temporary workaround for the
+   forward declaration mess of python types (cf vlcglue.h). If we do a
+   separate compilation, we have to declare some types as extern. But
+   the recommended way to forward declared types in python is
+   static... I am sorting the mess but in the meantime, this will
+   produce a working python module.
+*/
+#include "vlc_mediacontrol.c"
+#include "vlc_position.c"
+#include "vlc_instance.c"
+#include "vlc_mediaplayer.c"
+#include "vlc_media.c"
Index: bindings/python/MANIFEST.in
===================================================================
--- bindings/python/MANIFEST.in	(.../trunk)	(revision 0)
+++ bindings/python/MANIFEST.in	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,7 @@
+include vlcglue.h
+include vlc_mediacontrol.c
+include vlc_position.c
+include vlc_instance.c
+include vlc_mediaplayer.c
+include vlc_media.c
+include vlcwidget.py
Index: bindings/python/python-vlc.spec
===================================================================
--- bindings/python/python-vlc.spec	(.../trunk)	(revision 0)
+++ bindings/python/python-vlc.spec	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,71 @@
+%define name python-vlc
+%define version 1.0.0.90
+%define unmangled_version 1.0.0.90
+%define release 1
+%{!?python_sitelib: %global python_sitelib %(%{__python} -c "from distutils.sysconfig import get_python_lib; print get_python_lib()")}
+
+Summary: VLC bindings for python.
+Name: %{name}
+Version: %{version}
+Release: %{release}
+Source0: %{name}-%{unmangled_version}.tar.gz
+License: GPL
+Group: Development/Libraries
+BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-buildroot
+Prefix: %{_prefix}
+Vendor: Olivier Aubert <olivier.aubert@liris.cnrs.fr>
+Url: http://wiki.videolan.org/PythonBinding
+
+%description
+VLC bindings for python.
+
+This module provides bindings for the native libvlc API of the VLC
+video player. Documentation can be found on the VLC wiki :
+http://wiki.videolan.org/ExternalAPI
+
+This module also provides a MediaControl object, which implements an
+API inspired from the OMG Audio/Video Stream 1.0 specification.
+Documentation can be found on the VLC wiki :
+http://wiki.videolan.org/PythonBinding
+
+Example session (for the MediaControl API):
+
+import vlc
+mc=vlc.MediaControl(['--verbose', '1'])
+mc.playlist_add_item('movie.mpg')
+
+# Start the movie at 2000ms
+p=vlc.Position()
+p.origin=vlc.RelativePosition
+p.key=vlc.MediaTime
+p.value=2000
+mc.start(p)
+# which could be abbreviated as
+# mc.start(2000)
+# for the default conversion from int is to make a RelativePosition in MediaTime
+
+# Display some text during 2000ms
+mc.display_text('Some useless information', 0, 2000)
+
+# Pause the video
+mc.pause(0)
+
+# Get status information
+mc.get_stream_information()
+       
+
+%prep
+%setup -n %{name}-%{unmangled_version}
+
+%build
+env CFLAGS="$RPM_OPT_FLAGS" python setup.py build
+
+%install
+python setup.py install --root=$RPM_BUILD_ROOT --record=INSTALLED_FILES
+
+%clean
+rm -rf $RPM_BUILD_ROOT
+
+%files -f INSTALLED_FILES
+%defattr(-,root,root)
+%{python_sitelib}/vlcwidget.pyo
Index: bindings/python/README
===================================================================
--- bindings/python/README	(.../trunk)	(revision 0)
+++ bindings/python/README	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,21 @@
+* Testing
+
+If you try to compile the bindings from a development tree, you will
+have to specify the path for VLC modules, which cannot be guessed by
+the extension module (and are hardcoded for a standard installation,
+i.e. /usr/lib/vlc on *NIX)
+
+For vlc.MediaControl:
+mc=vlc.MediaControl('--plugin-path /path/to/vlc/directory'.split())
+
+For vlc.Instance:
+i=vlc.Instance('--plugin-path /path/to/vlc/directory'.split())
+
+* Skeleton generation (for developers of the module):
+
+** For method bindings:
+
+perl -n -e 'print "static PyObject *\nvlcInput_$2( PyObject *self, PyObject *args )\n{\n    libvlc_exception_t ex;\n    LIBVLC_TRY;\n    $1_$2( self->p_input, &ex);    LIBVLC_EXCEPT;\n    Py_INCREF( Py_None );\n    return Py_None;\n}\n\n" if /(libvlc_input)_(\w+)/ and ($2 ne "t")' ../../include/vlc/libvlc.h 
+
+** For method table:
+perl -n -e 'print "    { \"$2\", $1_$2, METH_VARARGS,\n      \"$2()\" },\n" if /^(vlcInstance)_(\w+)/' vlc_instance.c 
Index: configure.ac
===================================================================
--- configure.ac	(.../trunk)	(revision 13995)
+++ configure.ac	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -5735,6 +5735,17 @@
 AC_LANG_POP(C++)
 AM_CONDITIONAL(BUILD_MOZILLA,${mozilla})
 
+dnl
+dnl  Ivaylo's special access module for raw input from Python
+dnl
+AC_ARG_ENABLE(access-raw,
+  [  --enable-access-raw     Enable raw access module (default disabled)])
+if test "${enable_access_raw}" = "yes"
+then
+  VLC_ADD_PLUGIN([access_raw])
+fi
+
+
 dnl Tests for Osso and Xsp
 AC_CHECK_LIB(osso, osso_display_blanking_pause, [
   PKG_CHECK_MODULES(GLIB2, glib-2.0, [
Index: p2pnext-win32-setup-from-co.sh
===================================================================
--- p2pnext-win32-setup-from-co.sh	(.../trunk)	(revision 0)
+++ p2pnext-win32-setup-from-co.sh	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,193 @@
+#!/bin/bash
+
+# Written by Diego Andres Rabaioli, Arno Bakker
+
+# Important:
+# Check that you have installed the following tools:
+# -subversion
+# -mingw32
+# -automake
+# -libtool
+# -gettext
+# -cvs
+# -libgcrypt-dev
+#
+
+CONTRIB_NAME="contribs-0.9.9"
+CONTRIB_EXT=".tar.bz2"
+CONTRIB_URI="http://download.videolan.org/pub/videolan/testing/win32/"
+
+VLC_URI="https://svn.tribler.org/vlc/branches/plugin-1.0"
+VLC_REV="HEAD"  # HEAD = latest, set to specific revision for stability
+VLC_DIR="vlc-plugin-1.0-r$VLC_REV"
+VLC_LNK="_vlc"
+VLC_CONFIG_FLAGS="--host=i586-mingw32msvc --build=i386-linux \
+     --disable-gtk --disable-zvbi \
+     --enable-nls --enable-sdl --with-sdl-config-path=/usr/win32/bin \
+     --enable-faad --enable-flac --enable-theora \
+     --with-wx-config-path=/usr/win32/bin \
+     --with-freetype-config-path=/usr/win32/bin \
+     --with-fribidi-config-path=/usr/win32/bin \
+     --with-libgcrypt-prefix=/usr/win32 \
+     --disable-live555 --disable-caca \
+     --with-xml2-config-path=/usr/win32/bin \
+     --with-dvdnav-config-path=/usr/win32/bin \
+     --disable-cddax --disable-vcdx --enable-goom \
+     --enable-twolame --disable-dvdread \
+     --enable-debug --disable-swscale --disable-mad --disable-a52 --disable-dca \
+     --disable-qt4 --disable-skins2 --disable-atmo --enable-mozilla --with-mozilla-sdk-path=/usr/win32/gecko-sdk"
+
+
+# Build the environment
+build_env ()
+{
+  # VLC Contrib
+  p_head "Checking VLC CONTRIB is installed in /usr/win32"
+  if [ ! -d /usr/win32 ] ;
+  then
+      wget "$CONTRIB_URI$CONTRIB_NAME$CONTRIB_EXT"
+      echo "Please unpack $CONTRIB_NAME$CONTRIB_EXT as root from / to create /usr/win32"
+      exit 0
+  fi
+
+  # VLC
+  p_head "Installing VLC"
+  # Downloading
+  svn checkout $VLC_URI -r $VLC_REV $VLC_DIR
+  ln -s $VLC_DIR $VLC_LNK
+
+  echo
+  echo "The environment is ready. It's possible to compile Vlc now"
+  echo -n "Do you want to compile Vlc now? [y/n] "
+  read choise
+  if [ "$choise" = "y" ]; then
+    build_vlc
+  fi
+}
+
+# Clean the environment
+clean_env ()
+{
+  echo "This operation will delete the following files and directories:"
+  echo
+  echo "$CONTRIB_NAME"
+  echo "$CONTRIB_NAME$CONTRIB_EXT"
+  echo "$VLC_DIR"
+  echo "$VLC_LNK"
+  echo
+
+  echo -n "Are you sure you want to continue? [y/n] "
+  read choise
+  if [ "$choise" = "y" ]; then
+    p_head "Cleaning Environment"
+    rm -rf "$CONTRIB_NAME" "$CONTRIB_NAME$CONTRIB_EXT" "$VLC_DIR" "$VLC_LNK"
+  fi
+}
+
+# Build Vlc
+build_vlc ()
+{
+  # Bootstrap
+  p_head "Bootstrapping Vlc "
+  export PKG_CONFIG_PATH=/usr/win32/lib/pkgconfig
+  export CPPFLAGS="-I/usr/win32/include -I/usr/win32/include/ebml"
+  export LDFLAGS="-L/usr/win32/lib"
+  export CC=i586-mingw32msvc-gcc
+  export CXX=i586-mingw32msvc-g++
+  export CXXCPP=i586-mingw32msvc-cpp
+  cd $VLC_LNK
+  ./bootstrap
+  if [ $? -ne 0 ]; then
+    p_error "Error in bootstrapping Vlc."
+    exit 1
+  fi
+
+  # Configure
+  p_head "Configuring Vlc"
+  ./configure $VLC_CONFIG_FLAGS
+  if [ $? -ne 0 ]; then
+    p_error "Error in configuring Vlc."
+    exit 1
+  fi
+
+  # Make
+  p_head "Making Vlc"
+  make
+  if [ $? -ne 0 ]; then
+    p_error "Error in making Vlc."
+    exit 1
+  fi
+  cd ..
+
+}
+
+# Clean Vlc
+clean_vlc ()
+{
+  echo
+  echo "This operation will clean your Vlc source tree"
+  echo -n "Are you sure you want to continue? [y/n] "
+  read choise
+  if [ "$choise" = "y" ]; then
+    p_head "Cleaning Vlc"
+    cd _vlc
+    make clean
+    make distclean
+    cd ..
+  fi
+
+}
+
+# Print Header Utlity
+p_head ()
+{
+  echo
+  echo -en '\E[37;44m' "$1"; tput sgr0
+  echo
+  echo
+}
+
+# Print Header Utlity
+p_error ()
+{
+  echo
+  echo -en '\E[37;41m' "$1"; tput sgr0
+  echo
+  echo
+}
+
+
+# MAIN
+echo
+select selection in "build environment" "clean environment" "build vlc" "clean vlc"
+do
+  echo
+  case "$selection" in
+    "build environment" )
+    build_env
+    ;;
+
+    "clean environment" )
+    clean_env
+    ;;
+
+    "build vlc" )
+    build_vlc
+    ;;
+
+    "clean vlc" )
+    clean_vlc
+    ;;
+
+    * )
+      echo "inconsistent selection"
+    ;;
+  esac
+  break
+done
+
+p_head "Done."
+
+exit 0
+
+
Index: modules/demux/ts.c
===================================================================
--- modules/demux/ts.c	(.../trunk)	(revision 13995)
+++ modules/demux/ts.c	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -483,9 +483,10 @@
     {
         i_packet_size = TS_PACKET_SIZE_204;
     }
-    else if( p_demux->b_force )
+    else if( 1 || p_demux->b_force ) /* Arno: Patch so VLC will continue to interpret stream as MPEGTS */
     {
         i_packet_size = TS_PACKET_SIZE_188;
+        msg_Warn( p_demux, "TS module forced (lost sync)" );
     }
     else if( b_topfield )
     {
Index: modules/access/Modules.am
===================================================================
--- modules/access/Modules.am	(.../trunk)	(revision 13995)
+++ modules/access/Modules.am	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -41,6 +41,7 @@
 SOURCES_access_alsa = alsa.c
 SOURCES_access_oss = oss.c
 SOURCES_access_mtp = mtp.c
+SOURCES_access_raw = raw.c
 
 libvlc_LTLIBRARIES += \
 	libaccess_file_plugin.la \
@@ -50,4 +51,5 @@
 	libaccess_http_plugin.la \
 	libaccess_ftp_plugin.la \
 	libaccess_fake_plugin.la \
+	libaccess_raw_plugin.la \
 	$(NULL)
Index: modules/access/Makefile.am
===================================================================
--- modules/access/Makefile.am	(.../trunk)	(revision 13995)
+++ modules/access/Makefile.am	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -3,7 +3,7 @@
 
 basedir = access
 dir = access
-mods = access_alsa access_directory access_dv access_eyetv access_fake access_file access_ftp access_gnomevfs access_http access_jack access_mmap access_mtp access_oss access_smb access_tcp access_udp cdda dc1394 dvdnav dvdread pvr qtcapture v4l v4l2
+mods = access_alsa access_directory access_dv access_eyetv access_fake access_file access_ftp access_gnomevfs access_http access_jack access_mmap access_mtp access_oss access_raw access_smb access_tcp access_udp cdda dc1394 dvdnav dvdread pvr qtcapture v4l v4l2
 libvlc_LTLIBRARIES =  $(LTLIBaccess_alsa) $(LTLIBaccess_dv) $(LTLIBaccess_eyetv) $(LTLIBaccess_gnomevfs) $(LTLIBaccess_jack) $(LTLIBaccess_mmap) $(LTLIBaccess_mtp) $(LTLIBaccess_oss) $(LTLIBaccess_smb) $(LTLIBcdda) $(LTLIBdc1394) $(LTLIBdvdnav) $(LTLIBdvdread) $(LTLIBpvr) $(LTLIBqtcapture) $(LTLIBv4l) $(LTLIBv4l2)
 EXTRA_LTLIBRARIES =  libaccess_alsa_plugin.la libaccess_dv_plugin.la libaccess_eyetv_plugin.la libaccess_gnomevfs_plugin.la libaccess_jack_plugin.la libaccess_mmap_plugin.la libaccess_mtp_plugin.la libaccess_oss_plugin.la libaccess_smb_plugin.la libcdda_plugin.la libdc1394_plugin.la libdvdnav_plugin.la libdvdread_plugin.la libpvr_plugin.la libqtcapture_plugin.la libv4l_plugin.la libv4l2_plugin.la
 
@@ -152,6 +152,17 @@
 libaccess_oss_plugin_la_LIBADD = $(AM_LIBADD)
 libaccess_oss_plugin_la_DEPENDENCIES = $(top_srcdir)/src/libvlccore.sym
 
+# The access_raw plugin
+libaccess_raw_plugin_la_SOURCES = $(SOURCES_access_raw)
+nodist_libaccess_raw_plugin_la_SOURCES = $(nodist_SOURCES_access_raw)
+# Force per-target objects:
+libaccess_raw_plugin_la_CFLAGS = $(AM_CFLAGS)
+libaccess_raw_plugin_la_CXXFLAGS = $(AM_CXXFLAGS)
+libaccess_raw_plugin_la_OBJCFLAGS = $(AM_OBJCFLAGS)
+# Set LIBADD and DEPENDENCIES manually:
+libaccess_raw_plugin_la_LIBADD = $(AM_LIBADD)
+libaccess_raw_plugin_la_DEPENDENCIES = $(top_srcdir)/src/libvlccore.sym
+
 # The access_smb plugin
 libaccess_smb_plugin_la_SOURCES = $(SOURCES_access_smb)
 nodist_libaccess_smb_plugin_la_SOURCES = $(nodist_SOURCES_access_smb)
Index: modules/access/raw.c
===================================================================
--- modules/access/raw.c	(.../trunk)	(revision 0)
+++ modules/access/raw.c	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,335 @@
+/*****************************************************************************
+ * raw.c: Raw input module for reading input directly from a C program in the same
+ * address space, for example, and in particular, Python.
+ *
+ *****************************************************************************
+* Copyright (C) 2008-2009  Delft University of Technology. All rights reserved.
+ *
+ * Author: Ivaylo Haratcherev <I.J.Haratcherev@tudelft.nl>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Preamble
+ *****************************************************************************/
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <vlc_common.h>
+#include <vlc_plugin.h>
+#include <vlc_access.h>
+#include <vlc_demux.h>
+#include <vlc_image.h>
+
+
+#include <stdlib.h>
+#include <string.h>
+#if defined( WIN32 )
+    #define strtok_r(s,d,p) strtok(s,d)
+#endif
+
+#include <vlc/mediacontrol_structures.h>
+
+
+/*****************************************************************************
+ * Module descriptor
+ *****************************************************************************/
+static int  Open ( vlc_object_t * );
+static void Close( vlc_object_t * );
+
+
+#define CACHING_TEXT N_("Caching value in ms")
+#define CACHING_LONGTEXT N_( \
+    "Caching value for raw streams. This " \
+    "value should be set in milliseconds." )
+
+vlc_module_begin();
+    set_description( _("Raw input") );
+    set_shortname( _( "Raw" ) );
+    set_category( CAT_INPUT );
+    set_subcategory( SUBCAT_INPUT_ACCESS );
+    add_integer( "raw-caching", DEFAULT_PTS_DELAY / 1000, NULL, CACHING_TEXT, CACHING_LONGTEXT, true )
+    //  Ivaylo: What the heck is the second parameter in set_capability?
+    set_capability( "access", 10 );
+    add_shortcut( "raw" );
+    set_callbacks( Open, Close );
+vlc_module_end();
+
+
+/*****************************************************************************
+ * Exported prototypes
+ *****************************************************************************/
+static ssize_t Read( access_t *, uint8_t *, size_t );
+static int Seek( access_t *, int64_t );
+static int Control( access_t *, int, va_list );
+
+static int process_options( access_t *p_access );
+
+
+/*****************************************************************************
+ * Local prototypes
+ *****************************************************************************/
+struct access_sys_t
+{
+    int fd;
+
+    bool b_seekable;
+
+/* callback pointers */
+    raw_read_fnc_ptr    read_callback;
+    raw_seek_fnc_ptr    seek_callback;
+    int fsize;
+};
+
+
+
+
+/*****************************************************************************
+ * Open:
+ *****************************************************************************/
+static int Open( vlc_object_t *p_this )
+{
+    access_t     *p_access = (access_t*)p_this;
+    access_sys_t *p_sys;
+
+    /* Set up p_access */
+    p_access->pf_read = Read;
+    p_access->pf_block = NULL;
+    p_access->pf_control = Control;
+    p_access->pf_seek = Seek;
+    p_access->info.i_update = 0;
+    p_access->info.i_size = 0;
+    p_access->info.i_pos = 0;
+    p_access->info.b_eof = false;
+    p_access->info.i_title = 0;
+    p_access->info.i_seekpoint = 0;
+    p_access->p_sys = p_sys = malloc( sizeof( access_sys_t ) );
+    memset( p_sys, 0, sizeof( access_sys_t ) );
+    p_sys->fd = -1;
+    p_sys->b_seekable = true;
+    p_sys->read_callback = NULL;
+    p_sys->seek_callback = NULL;
+    p_sys->fsize = 0;
+    msg_Dbg( p_access, "Open raw before process options. MRL was: %s", p_access->psz_path );
+
+    if ( process_options(p_access) != VLC_SUCCESS )
+    {
+        msg_Err( p_access, "Bad MRL, please check the option line "
+                          "(MRL was: %s)",
+                          p_access->psz_path );
+        free( p_sys );
+        p_access->p_sys = NULL;
+        return VLC_EGENERIC;
+    }
+    p_access->info.i_size = p_sys->fsize;
+    msg_Dbg( p_access, "   read_callback %p, seek_callback %p, fsize %d",
+        p_sys->read_callback, p_sys->seek_callback, p_sys->fsize);
+
+     /* PTS delay */
+    var_Create( p_access, "raw-caching", VLC_VAR_INTEGER |VLC_VAR_DOINHERIT );
+
+    return VLC_SUCCESS;
+}
+
+/*****************************************************************************
+ * Close:
+ *****************************************************************************/
+static void Close( vlc_object_t *p_this )
+{
+    access_t     *p_access = (access_t*)p_this;
+    access_sys_t *p_sys = p_access->p_sys;
+
+    msg_Dbg( p_access, "Close raw...");
+
+    free( p_sys );
+}
+
+/*****************************************************************************
+ * Read: Read up to i_len bytes from the raw connection and place in
+ * p_buffer. Return the actual number of bytes read
+ *****************************************************************************/
+static ssize_t Read( access_t *p_access, uint8_t *p_buffer, size_t i_len )
+{
+    access_sys_t *p_sys = p_access->p_sys;
+    int i_read;
+
+/*    msg_Err( p_access, "Read...");*/
+
+    if( p_access->info.i_size > 0 &&
+        i_len + p_access->info.i_pos > p_access->info.i_size )
+    {
+        if( ( i_len = p_access->info.i_size - p_access->info.i_pos ) == 0 )
+        {
+            p_access->info.b_eof = true;
+            return 0;
+        }
+    }
+
+
+    if( p_sys->read_callback )
+        i_read = p_sys->read_callback(p_buffer, i_len, p_sys->fd);
+    else
+        i_read = 0;
+
+    if( i_read > 0 )
+        p_access->info.i_pos += i_read;
+
+    //msg_Dbg( p_access, "Read: i_read= %d", i_read );
+    return i_read;
+}
+
+
+
+/*****************************************************************************
+ * Seek: close and re-open a connection at the right place
+ *****************************************************************************/
+static int Seek( access_t *p_access, int64_t i_pos )
+{
+    access_sys_t *p_sys = p_access->p_sys;
+    msg_Dbg( p_access, "trying to seek to %lld", i_pos );
+
+    if( p_sys->seek_callback ) {
+        if (!p_sys->seek_callback(i_pos, p_sys->fd)) {
+            p_access->info.i_pos = i_pos;
+            if( p_access->info.i_size < p_access->info.i_pos )
+            {
+                msg_Err( p_access, "seeking too far" );
+                p_access->info.i_pos = p_access->info.i_size;
+            }
+            else if( p_access->info.i_pos < 0 )
+            {
+                msg_Err( p_access, "seeking too early" );
+                p_access->info.i_pos = 0;
+            }
+            /* Reset eof */
+            p_access->info.b_eof = false;
+            return VLC_SUCCESS;
+        }
+    }
+
+    return VLC_EGENERIC;
+}
+
+
+/*****************************************************************************
+ * Control:
+ *****************************************************************************/
+static int Control( access_t *p_access, int i_query, va_list args )
+{
+    access_sys_t *p_sys = p_access->p_sys;
+    bool   *pb_bool;
+    int64_t      *pi_64;
+
+    msg_Dbg( p_access, "Control...");
+    switch( i_query )
+    {
+        /* */
+        case ACCESS_CAN_SEEK:
+            pb_bool = (bool *)va_arg( args, bool* );
+            *pb_bool = p_sys->b_seekable;
+            break;
+        case ACCESS_CAN_FASTSEEK:
+            pb_bool = (bool*)va_arg( args, bool* );
+            *pb_bool = true; // Arno: Hack to get AVI seeking to work
+            break;
+        case ACCESS_CAN_PAUSE:
+        case ACCESS_CAN_CONTROL_PACE:
+            pb_bool = (bool*)va_arg( args, bool* );
+            *pb_bool = true;
+            break;
+
+         /* */
+        case ACCESS_GET_PTS_DELAY:
+            pi_64 = (int64_t*)va_arg( args, int64_t * );
+            *pi_64 = (int64_t)var_GetInteger( p_access, "raw-caching" ) * 1000;
+            break;
+
+        case ACCESS_SET_PAUSE_STATE:
+            /* Nothing to do */
+            break;
+
+        case ACCESS_GET_TITLE_INFO:
+        case ACCESS_SET_TITLE:
+        case ACCESS_SET_SEEKPOINT:
+        case ACCESS_SET_PRIVATE_ID_STATE:
+        case ACCESS_GET_META:
+        case ACCESS_GET_PRIVATE_ID_STATE:
+        case ACCESS_GET_CONTENT_TYPE:
+            return VLC_EGENERIC;
+
+        default:
+            msg_Warn( p_access, "unimplemented query %d in control", i_query );
+            return VLC_EGENERIC;
+
+    }
+    return VLC_SUCCESS;
+}
+
+
+static int process_options( access_t *p_access )
+{
+    access_sys_t *p_sys = p_access->p_sys;
+
+    char *psz_dup;
+    char *psz_parser;
+    char *token = NULL;
+    char *state = NULL;
+
+    if( strncmp(p_access->psz_path,"raw",3) != 0 )
+        return VLC_EGENERIC;
+
+    psz_dup = strdup( p_access->psz_path );
+    psz_parser = psz_dup;
+    for( token = strtok_r( psz_parser,":",&state); token;
+         token = strtok_r( NULL, ":", &state ) )
+    {
+        if( strncmp( token, "rptr=", strlen("rptr=") ) == 0)
+        {
+            token += strlen("rptr=");
+            sscanf( token, "0x%p", &p_sys->read_callback );
+            if (p_sys->read_callback == NULL)
+            {
+               // snprintf in src/control/mediacontrol_core.c prints 0x0xADDR
+               // on crosscompiled Win32
+               sscanf( token, "0x0x%p", &p_sys->read_callback );
+            }
+        }
+        else if( strncmp( token, "sptr=", strlen("sptr=") ) == 0)
+        {
+            token += strlen("sptr=");
+            sscanf( token, "0x%p", &p_sys->seek_callback );
+            if (p_sys->seek_callback == NULL)
+            {
+                // snprintf in src/control/mediacontrol_core.c prints 0x0xADDR
+                // on crosscompiled Win32
+                sscanf( token, "0x0x%p", &p_sys->seek_callback );
+            }
+        }
+        else if( strncmp( token, "fsize=", strlen("fsize=") ) == 0)
+        {
+            token += strlen("fsize=");
+            sscanf( token, "%d", &p_sys->fsize );  // Arno: TODO: shouldn't this be int64 like seek's offset?
+        }
+        else if( strncmp( token, "id=", strlen("id=") ) == 0)
+        {
+            token += strlen("id=");
+            sscanf( token, "%d", &p_sys->fd );
+        }
+    }
+    if( psz_dup ) free( psz_dup );
+    return VLC_SUCCESS;
+}
Index: include/vlc/mediacontrol.h
===================================================================
--- include/vlc/mediacontrol.h	(.../trunk)	(revision 13995)
+++ include/vlc/mediacontrol.h	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -225,6 +225,30 @@
 VLC_PUBLIC_API char * mediacontrol_get_mrl( mediacontrol_Instance *self,
                                             mediacontrol_Exception *exception );
 
+
+
+/**
+ *  Added by Ivaylo:
+ *
+ * Set the size and ID of the content to be played, and the callback functions
+ * for reading and seeking in the content via the raw C access module.
+ *
+ * \param self the mediacontrol instance
+ * \param read_callback the function for VLC to call when it wants to read
+ * \param seek_callback the function for VLC to call when it wants to seek
+ * \param i_fsize size of the content
+ * \param id unique ID of the content
+ * \param exception an initialized exception pointer
+ */
+VLC_PUBLIC_API void mediacontrol_set_raw_callbacks( mediacontrol_Instance *self,
+							      raw_read_fnc_ptr read_callback,
+								  raw_seek_fnc_ptr seek_callback,
+								  int i_fsize,
+								  int id,
+                                  mediacontrol_Exception *exception );
+
+
+
 /*****************************************************************************
  * A/V functions
  *****************************************************************************/
Index: include/vlc/mediacontrol_structures.h
===================================================================
--- include/vlc/mediacontrol_structures.h	(.../trunk)	(revision 13995)
+++ include/vlc/mediacontrol_structures.h	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -135,6 +135,14 @@
 } mediacontrol_StreamInformation;
 
 
+/**
+ * For Ivaylo's mediacontrol_set_raw_callbacks()
+ */
+
+typedef int (* raw_read_fnc_ptr) ( uint8_t *p_data, int i_data, int id );
+typedef	int (* raw_seek_fnc_ptr) ( int64_t i_pos, int id );
+
+
 # ifdef __cplusplus
 }
 # endif
Index: projects/activex/plugin.cpp
===================================================================
--- projects/activex/plugin.cpp	(.../trunk)	(revision 13995)
+++ projects/activex/plugin.cpp	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -40,6 +40,11 @@
 
 #include "utils.h"
 
+// P2P-Next
+#include "p2pcontrol.h"
+#include <vlc_osd.h>
+
+
 #include <stdio.h>
 #include <string.h>
 #include <winreg.h>
@@ -230,6 +235,12 @@
     vlcOleObject = new VLCOleObject(this);
     vlcSupportErrorInfo = new VLCSupportErrorInfo(this);
 
+    // P2P-Next
+    p2pControl = new P2PControl();
+    p2pStatus = NULL;
+#if _MEDIACONTROL_
+    mediaControl    = NULL;
+#endif
     // configure controlling IUnknown interface for implemented interfaces
     this->pUnkOuter = (NULL != pUnkOuter) ? pUnkOuter : dynamic_cast<LPUNKNOWN>(this);
 
@@ -248,6 +259,9 @@
     */
     AddRef();
 
+    // P2P-Next
+    delete p2pControl;
+
     delete vlcSupportErrorInfo;
     delete vlcOleObject;
     delete vlcDataObject;
@@ -374,6 +388,10 @@
         HimetricFromDP(hDC, (LPPOINT)&_extent, 1);
         DeleteDC(hDC);
 
+        // P2P-Next
+        if( ! p2pControl->startup() ) // TODO : check what happen if !startup
+          return E_FAIL;
+
         return S_OK;
     }
     return CO_E_ALREADYINITIALIZED;
@@ -449,7 +467,7 @@
 
     HKEY h_key;
     char p_pluginpath[MAX_PATH];
-    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, TEXT("Software\\VideoLAN\\VLC"),
+    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, TEXT("Software\\SwarmPlugin"),
                       0, KEY_READ, &h_key ) == ERROR_SUCCESS )
     {
         DWORD i_type, i_data = MAX_PATH;
@@ -465,6 +483,7 @@
                     strcat( p_pluginpath, "\\plugins" );
                     ppsz_argv[ppsz_argc++] = "--plugin-path";
                     ppsz_argv[ppsz_argc++] = p_pluginpath;
+                    writeOnLog( "VlcPlugin: Found plugins directory: %s", p_pluginpath );
                 }
             }
         }
@@ -479,6 +498,11 @@
     ppsz_argv[ppsz_argc++] = "--no-media-library";
     ppsz_argv[ppsz_argc++] = "--ignore-config";
     ppsz_argv[ppsz_argc++] = "--intf=dummy";
+    ppsz_argv[ppsz_argc++] = "--no-osd";
+    ppsz_argv[ppsz_argc++] = "--no-video-title-show";
+    // Arno: to log to file, uncomment extraintf and logfile lines:
+    // ppsz_argv[ppsz_argc++] = "--extraintf=logger";
+    //ppsz_argv[ppsz_argc++] = "--logfile=C:\\VLC-logfile.txt";
 
     // loop mode is a configuration option only
     if( _b_autoloop )
@@ -505,6 +529,7 @@
         libvlc_audio_set_mute(_p_libvlc, TRUE, NULL);
     }
 
+
     // initial playlist item
     if( SysStringLen(_bstr_mrl) > 0 )
     {
@@ -535,7 +560,8 @@
         }
         if( NULL != psz_mrl )
         {
-            const char *options[1];
+#ifdef ORIG
+	  const char *options[1];
             int i_options = 0;
 
             char timeBuffer[32];
@@ -544,8 +570,23 @@
                 snprintf(timeBuffer, sizeof(timeBuffer), ":start-time=%d", _i_time);
                 options[i_options++] = timeBuffer;
             }
+
             // add default target to playlist
             playlist_add_extended_untrusted(psz_mrl, i_options, options, NULL);
+#else
+            // P2P-Next
+	    // The URL is that of a torrent file that we want to watch, forward to BG process
+            p2pControl->regEventCB< VLCPlugin >( EV_PLAY,   this, &VLCPlugin::onPlay );
+            p2pControl->regEventCB< VLCPlugin >( EV_PAUSE,  this, &VLCPlugin::onPause );
+            p2pControl->regEventCB< VLCPlugin >( EV_RESUME, this, &VLCPlugin::onResume );
+            p2pControl->regEventCB< VLCPlugin >( EV_STOP,   this, &VLCPlugin::onStop );
+            p2pControl->regEventCB< VLCPlugin >( EV_INFO,   this, &VLCPlugin::onInfo );
+
+            if( ! p2pControl->sendTorrent( string( psz_mrl ) ) )
+            {
+	        writeOnLog( "Plugin: initVLC: Could NOT send torrent to BG process" );
+	    }
+#endif
             CoTaskMemFree(psz_mrl);
         }
     }
@@ -554,7 +595,7 @@
 void VLCPlugin::setErrorInfo(REFIID riid, const char *description)
 {
     vlcSupportErrorInfo->setErrorInfo( getClassID() == CLSID_VLCPlugin2 ?
-        OLESTR("VideoLAN.VLCPlugin.2") : OLESTR("VideoLAN.VLCPlugin.1"),
+        OLESTR("P2PNext.SwarmPlugin.2") : OLESTR("P2PNext.SwarmPlugin.1"),
         riid, description );
 };
 
@@ -1104,4 +1145,109 @@
     return item;
 }
 
+// P2P-Next
+void VLCPlugin::onPlay( const char * stream )
+{
+    const char *options[1];
+    int i_options = 0;
 
+    char timeBuffer[32];
+    if( _i_time )
+    {
+        snprintf( timeBuffer, sizeof(timeBuffer), ":start-time=%d", _i_time );
+        options[i_options++] = timeBuffer;
+    }
+    // add default target to playlist
+    playlist_add_extended_untrusted(stream, i_options, options, NULL);
+
+    if( _b_autoplay )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        playlist_play(&ex);
+        if( libvlc_exception_raised(&ex) )
+	{
+	    writeOnLog( "VLCPlugin::onPlay: Exception" );
+	    writeOnLog( libvlc_exception_get_message(&ex) );
+	    libvlc_exception_clear(&ex);
+	    return;
+	}
+
+        // Arno, 2009-08-19: Not sure whether we need these still. vlccontrol.cpp uses them,
+	// vlccontrol2.cpp doesn't.
+        fireOnPlayEvent();
+    }
+}
+
+void VLCPlugin::onPause( const char * nothing )
+{
+    libvlc_exception_t ex;
+    libvlc_exception_init(&ex);
+
+    playlist_pause(&ex);
+    if( libvlc_exception_raised(&ex) )
+    {
+        writeOnLog( "VLCPlugin::onPause: Exception" );
+        writeOnLog( libvlc_exception_get_message(&ex) );
+        libvlc_exception_clear(&ex);
+        return;
+    }
+
+    fireOnPauseEvent();
+}
+
+void VLCPlugin::onResume( const char * nothing )
+{
+    libvlc_exception_t ex;
+    libvlc_exception_init(&ex);
+
+    playlist_play(&ex);
+    if( libvlc_exception_raised(&ex) )
+    {
+        writeOnLog( "VLCPlugin::onResume: Exception" );
+        writeOnLog( libvlc_exception_get_message(&ex) );
+        libvlc_exception_clear(&ex);
+        return;
+    }
+
+    fireOnPlayEvent();
+}
+
+void VLCPlugin::onStop( const char * nothing )
+{
+    libvlc_exception_t ex;
+    libvlc_exception_init(&ex);
+
+    playlist_stop(&ex);
+    if( libvlc_exception_raised(&ex) )
+    {
+        writeOnLog( "VLCPlugin::onResume: Exception" );
+        writeOnLog( libvlc_exception_get_message(&ex) );
+        libvlc_exception_clear(&ex);
+        return;
+    }
+
+    fireOnStopEvent();
+}
+
+void VLCPlugin::onInfo( const char * infostr )
+{
+    // Save copy of status message
+	if (this->p2pStatus != NULL)
+	{
+		free(this->p2pStatus);
+	}
+	this->p2pStatus = (char *)malloc((strlen(infostr)+1)*sizeof(char));
+	strcpy(this->p2pStatus,infostr);
+}
+
+// For JavaScript API
+const char *VLCPlugin::getP2PStatus()
+{
+    if (this->p2pStatus == NULL)
+		return "";
+	else
+		return this->p2pStatus;
+}
+
Index: projects/activex/Makefile.in
===================================================================
--- projects/activex/Makefile.in	(.../trunk)	(revision 13995)
+++ projects/activex/Makefile.in	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -77,7 +77,7 @@
 	objectsafety.h dataobject.cpp dataobject.h viewobject.cpp \
 	viewobject.h supporterrorinfo.cpp supporterrorinfo.h \
 	vlccontrol.cpp vlccontrol.h vlccontrol2.cpp vlccontrol2.h \
-	plugin.cpp plugin.h axvlc_idl.c axvlc_idl.h guiddef.h
+	plugin.cpp plugin.h p2pcontrol.cpp p2pcontrol.h axvlc_idl.c axvlc_idl.h guiddef.h
 am__objects_1 = axvlc_la-main.lo axvlc_la-utils.lo \
 	axvlc_la-olecontrol.lo axvlc_la-oleinplaceactiveobject.lo \
 	axvlc_la-oleinplaceobject.lo axvlc_la-oleobject.lo \
@@ -86,7 +86,7 @@
 	axvlc_la-connectioncontainer.lo axvlc_la-objectsafety.lo \
 	axvlc_la-dataobject.lo axvlc_la-viewobject.lo \
 	axvlc_la-supporterrorinfo.lo axvlc_la-vlccontrol.lo \
-	axvlc_la-vlccontrol2.lo axvlc_la-plugin.lo \
+	axvlc_la-vlccontrol2.lo axvlc_la-plugin.lo axvlc_la-p2pcontrol.lo \
 	axvlc_la-axvlc_idl.lo
 @BUILD_ACTIVEX_TRUE@am_axvlc_la_OBJECTS = $(am__objects_1)
 axvlc_la_OBJECTS = $(am_axvlc_la_OBJECTS)
@@ -716,6 +716,8 @@
     vlccontrol2.h \
     plugin.cpp \
     plugin.h \
+    plugin.cpp \
+    plugin.h \
     axvlc_idl.c \
     axvlc_idl.h \
     guiddef.h \
@@ -845,6 +847,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/axvlc_la-persiststorage.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/axvlc_la-persiststreaminit.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/axvlc_la-plugin.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/axvlc_la-p2pcontrol.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/axvlc_la-provideclassinfo.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/axvlc_la-supporterrorinfo.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/axvlc_la-utils.Plo@am__quote@
@@ -1027,6 +1030,15 @@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(axvlc_la_CXXFLAGS) $(CXXFLAGS) -c -o axvlc_la-plugin.lo `test -f 'plugin.cpp' || echo '$(srcdir)/'`plugin.cpp
 
+
+axvlc_la-p2pcontrol.lo: p2pcontrol.cpp
+@am__fastdepCXX_TRUE@	$(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(axvlc_la_CXXFLAGS) $(CXXFLAGS) -MT axvlc_la-p2pcontrol.lo -MD -MP -MF $(DEPDIR)/axvlc_la-p2pcontrol.Tpo -c -o axvlc_la-p2pcontrol.lo `test -f 'p2pcontrol.cpp' || echo '$(srcdir)/'`p2pcontrol.cpp
+@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/axvlc_la-p2pcontrol.Tpo $(DEPDIR)/axvlc_la-p2pcontrol.Plo
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='p2pcontrol.cpp' object='axvlc_la-p2pcontrol.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(axvlc_la_CXXFLAGS) $(CXXFLAGS) -c -o axvlc_la-p2pcontrol.lo `test -f 'p2pcontrol.cpp' || echo '$(srcdir)/'`p2pcontrol.cpp
+
+
 mostlyclean-libtool:
 	-rm -f *.lo
 
Index: projects/activex/p2pcontrol.cpp
===================================================================
--- projects/activex/p2pcontrol.cpp	(.../trunk)	(revision 0)
+++ projects/activex/p2pcontrol.cpp	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,505 @@
+/* 
+ * Written by Diego Andres Rabaioli
+ * see P2P-Next-LICENSE.txt for license information
+ */
+
+#include "p2pcontrol.h"
+#include <string>
+
+#define P_DEBUG
+
+#ifdef P_DEBUG
+#include <stdio.h>
+#include <stdarg.h>
+#endif
+
+////////
+// TODO : Diego : Just for debug... remove it or move to vlc log system
+////////
+void writeOnLog( const char * msg, ... )
+{
+#ifdef P_DEBUG
+  static std::string logPath = "";
+
+  if( logPath.empty() )
+  {
+    char   tmp[256];
+    LONG   result;
+    HKEY   hKey;
+    WCHAR  Logpath[256]; // TODO : Fix this
+    DWORD  bufLen = sizeof( Logpath );
+
+    // Look in the Windows registry for installation path
+    result = RegOpenKeyEx( HKEY_LOCAL_MACHINE, PLUGIN_REG_KEY, 0, KEY_QUERY_VALUE, &hKey );
+    if( result != ERROR_SUCCESS ) { RegCloseKey( hKey ); return; }
+    result = RegQueryValueEx( hKey, LOG_PATH_ELEMENT, NULL, NULL, (LPBYTE)Logpath, &bufLen);
+    if( result != ERROR_SUCCESS ) { RegCloseKey( hKey ); return; }
+    RegCloseKey( hKey );
+    wcstombs( tmp, Logpath, 256 );
+    logPath.assign( tmp );
+    logPath.append( "\\" );
+    logPath.append( LOG_FILE_NAME );
+  }
+
+  if( ! logPath.empty() )
+  {
+    FILE * file;
+    file = fopen( logPath.c_str(), "a" );
+    if( file == NULL ) return;
+
+    va_list args;
+    va_start( args, msg );
+    vfprintf( file, msg, args );
+    va_end( args );
+    fputs( "\r\n", file );
+    fclose( file );
+  }
+#endif
+};
+
+// Thread parameters
+typedef struct {
+  BGPConnection  * connection;
+  event_cb_map_t * eventMap;
+  HANDLE *         syncEvent;
+  HANDLE *         syncMutex;
+} ThreadParams;
+
+
+///////////////////////////
+// BGPConnection
+///////////////////////////
+BGPConnection::BGPConnection( const int port, const std::string bgAddress )
+{
+  mBGAddress   = bgAddress;
+  mPort        = port;
+  mSocketState = S_DOWN;
+}
+
+///////////////////////////
+BGPConnection::~BGPConnection()
+{
+  disconnect();
+}
+
+///////////////////////////
+bool BGPConnection::connect()
+{
+  WSADATA            wsaData;
+  struct sockaddr_in serverAddress;
+  int                iResult;
+
+  // Just to be in a consistent state
+  if( mSocketState == S_UP )
+    return true;
+  else if( mSocketState != S_DOWN )
+    disconnect();
+
+  // Init Winsock
+  iResult = WSAStartup( MAKEWORD( 2, 2 ), &wsaData );
+  if( iResult != 0 )
+    return disconnect();
+
+  mSocketState = S_STARTED;
+
+  // Create socket
+  if( ( mServerSocket = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP ) ) == INVALID_SOCKET )
+    return disconnect();
+
+  mSocketState = S_CREATED;
+
+  memset( &serverAddress, 0, sizeof( serverAddress ) );
+  serverAddress.sin_family      = AF_INET;
+  serverAddress.sin_port        = htons( mPort );
+  serverAddress.sin_addr.s_addr = inet_addr( mBGAddress.c_str() );
+
+  // Connect to the BG process server
+  if( ( ::connect( mServerSocket, (struct sockaddr *)&serverAddress,
+                 sizeof( serverAddress ) ) ) == SOCKET_ERROR )
+  {
+    writeOnLog( "BGPConnection: Could not connect to server" );
+    writeOnLog( "%i Socket Server : %i Server Addres : %i", WSAGetLastError(), mServerSocket, serverAddress.sin_addr.s_addr );
+    return disconnect();
+  }
+
+  writeOnLog( "BGPConnection: CONNECTED" );
+
+  mSocketState = S_UP;
+  return true;
+
+}
+
+///////////////////////////
+bool BGPConnection::disconnect()
+{
+// Shut down the connection depending on the state of the socket
+// It basically returns always false (stupid code optimization reason)
+  #ifdef P_DEBUG_2
+  writeOnLog( "BGPConnection: Shutting down connection from status %d", mSocketState );
+  #endif
+
+  if( mSocketState == S_DOWN )
+    return false;
+
+  if( mSocketState >= S_CREATED )
+  {
+    closesocket( mServerSocket );
+    mServerSocket = INVALID_SOCKET;
+  }
+
+  WSACleanup();
+  mSocketState = S_DOWN;
+  return false;
+}
+
+///////////////////////////
+bool BGPConnection::sendMsg( const std::string & message ) const
+{
+  int res;
+
+  // Check socket status
+  if( mSocketState != S_UP )
+    return false;
+
+  // Complete message
+  std::string msg = message + "\r\n";
+  // Send Request
+  res = send( mServerSocket, msg.c_str(), msg.length(), 0 );
+  writeOnLog( "BGPConnection: Sending: %s", message.c_str() );
+
+  if( res == SOCKET_ERROR )
+  {
+    writeOnLog( "BGPConnection: Error in sending message" );
+    return false;
+  }
+
+  return true;
+}
+
+///////////////////////////
+bool BGPConnection::recvMsg( std::string & message ) const
+{
+  char inBuffer[ IN_BUF_LEN ];
+  int  res;
+
+  if( mSocketState != S_UP )
+    return false;
+
+  message = "";
+  while( true )
+  {
+    res = recv( mServerSocket, inBuffer, IN_BUF_LEN, 0 );
+
+    if( res <= 0 )
+    {
+      writeOnLog( "BGPConnection: Error in receiving" );
+      message = "SHUTDOWN";
+      return false;
+    }
+
+    message.append( inBuffer, res );
+    if( ! message.compare( message.size() - 2, 2, "\r\n" ) )
+      break;
+  }
+  // Trim "\r\n"
+  message.erase( message.size() - 2 );
+
+  writeOnLog( "BGPConnection: RECEIVED : %s", message.c_str() );
+
+  return true;
+}
+
+///////////////////////////
+// P2PControl
+///////////////////////////
+P2PControl::P2PControl( const int port, const std::string bgAddress ) :
+  mEventCBMap(), mProtoState( P_DOWN ) 
+{
+  mConnection  = new BGPConnection( port, bgAddress );
+  mEventThread = NULL;
+}
+
+///////////////////////////
+P2PControl::~P2PControl()
+{
+  shutdown();
+}
+
+///////////////////////////
+bool P2PControl::startup()
+{
+  writeOnLog( "P2PControl::starting up..." );
+
+  // Check if communication protocol is already up.
+  if( mProtoState == P_UP )
+    return true;
+
+  // Try to connect to the BG Process. If it doesn't succeed then
+  // try to start the BG Process and try to connect againg.
+  if( ! mConnection->connect() )
+    if( ! startBGProcess() || ! mConnection->connect() )
+      return mConnection->disconnect();
+
+  // Check if the thread is already running.
+  if( mEventThread != NULL )
+    return true;
+
+  // Init syncronization event
+  mSyncEvent = CreateEvent( NULL, false, false, NULL );
+  if( mSyncEvent == NULL )
+  { writeOnLog( "P2PControl: Error in creating syncronization event" ); return false; }
+
+  // Init syncronization mutex
+  mSyncMutex = CreateMutex( NULL, false, NULL );
+  if( mSyncMutex == NULL )
+  { writeOnLog( "P2PControl: Error in creating syncronization mutex" ); return false; }
+
+  // Init the thread arguments
+  ThreadParams * threadParams = new ThreadParams;
+  threadParams->connection    = mConnection;
+  threadParams->eventMap      = &mEventCBMap;
+  threadParams->syncEvent     = &mSyncEvent;
+  threadParams->syncMutex     = &mSyncMutex;
+
+  // Start the Event Loop
+  mEventThread = CreateThread( NULL,
+                               0,
+                               &eventLoop,
+                               threadParams,
+                               0,
+                               NULL );
+
+  if( mEventThread == NULL )
+  {
+    writeOnLog( "P2PControl: Could not start event loop thread" );
+    delete threadParams;
+    return false;
+  }
+
+  // After the BG Process starts up, a notification event is sent to
+  // the plug-in, it means we are now able to connect to the BG.
+  // Just wait for it.
+  if( WaitForSingleObject( mSyncEvent, INFINITE ) != WAIT_OBJECT_0 )
+    writeOnLog( "Sync Error while Starting up the event thread" );
+
+  delete threadParams;
+
+  mProtoState = P_UP;
+
+  return true;
+}
+
+///////////////////////////
+bool P2PControl::shutdown()
+{
+  // Send a shutdown request to the BG and wait
+  // to receive the syncronization event back.
+  DWORD res;
+  mConnection->sendMsg( "SHUTDOWN" );
+  res = WaitForSingleObject( mSyncEvent, 2000 );
+  if( res == WAIT_TIMEOUT ) writeOnLog( "Sync Error while closing thread" );
+  else writeOnLog( "P2PControl: Thread cleanly exited" );
+
+  // Close all handlers and prepare to exit.
+  CloseHandle( mEventThread );
+  CloseHandle( mSyncEvent );
+  CloseHandle( mSyncMutex );
+  delete mConnection;
+  mProtoState = P_DOWN;
+
+  return true;
+}
+
+///////////////////////////
+bool P2PControl::startBGProcess()
+{
+  LONG         result;
+  HKEY         hKey;
+  WCHAR        BGpath[256]; // TODO : Fix this
+  DWORD        bufLen = sizeof( BGpath );
+
+  // Look in the Windows registry to get the path of the BG
+  result = RegOpenKeyEx( HKEY_LOCAL_MACHINE, PLUGIN_REG_KEY, 0, KEY_QUERY_VALUE, &hKey );
+  if( result != ERROR_SUCCESS ) { RegCloseKey( hKey ); return false; }
+  result = RegQueryValueEx( hKey, BG_PATH_ELEMENT, NULL, NULL, (LPBYTE)BGpath, &bufLen);
+  if( result != ERROR_SUCCESS ) { RegCloseKey( hKey ); return false; }
+  RegCloseKey( hKey );
+
+  // Set up variables
+  STARTUPINFOW        startupInfo;
+  PROCESS_INFORMATION processInfo;
+  memset( &startupInfo, 0, sizeof( startupInfo ) );
+  memset( &processInfo, 0, sizeof( processInfo ) );
+  startupInfo.cb = sizeof( startupInfo );
+
+  writeOnLog( "Starting BG Process..." );
+  // Finally start the BG Process
+  bool started = CreateProcess( BGpath,
+                                NULL,
+                                NULL,
+                                NULL,
+                                false,
+                                CREATE_NO_WINDOW,
+                                NULL,
+                                NULL,
+                                &startupInfo,
+                                &processInfo );
+
+  // Wait the process to startup and send a 'startup' event
+  HANDLE startupEvent = CreateEvent( NULL, false, false, L"startupEvent" );
+  if( startupEvent == NULL )
+  {
+    writeOnLog( "P2PControl: Error in creating syncronization event: Could not create BG Process" );
+    started = false;
+  }
+  else
+  {
+    if( started )
+    {
+      writeOnLog( "Waiting Startup event from BG" );
+      ::WaitForSingleObject( startupEvent, INFINITE );
+      writeOnLog( "BGProcess Created" );
+    }
+    else
+    {
+      writeOnLog( "Could not start BG Process" );
+      writeOnLog(  "Last Error code : %i", GetLastError() );
+    }
+
+    CloseHandle( startupEvent );
+  }
+
+  CloseHandle( processInfo.hProcess );
+  CloseHandle( processInfo.hThread );
+
+  return started;
+}
+
+///////////////////////////
+bool P2PControl::sendTorrent( const std::string torrent )
+{
+  #ifdef P_DEBUG_2
+  writeOnLog( "P2PControl: Sending Torrent..." );
+  #endif
+
+  // Send START command with the torrent
+  std::string command = "START " + torrent;
+  return mConnection->sendMsg( command );
+}
+
+///////////////////////////
+DWORD WINAPI P2PControl::eventLoop( LPVOID params )
+{
+  BGPConnection *          connection;
+  event_cb_map_t *         eventMap;
+  std::string              serverCmd, command;
+  bg_event_t               event;
+  event_cb_map_t::iterator eventIt;
+  HANDLE *                 syncEvent;
+  HANDLE *                 syncMutex;
+  // Just for iterating through the events
+  std::pair< event_cb_map_t::iterator, event_cb_map_t::iterator > equalEventsIt;
+
+  // Parse parameters
+  connection = ( (ThreadParams *)params )->connection;
+  eventMap   = ( (ThreadParams *)params )->eventMap;
+  syncEvent  = ( (ThreadParams *)params )->syncEvent;
+  syncMutex  = ( (ThreadParams *)params )->syncMutex;
+
+  // TODO : Check here
+  SetEvent( *syncEvent ); // Main thread can delete ThreadParams now
+
+  writeOnLog( "P2P Thread: STARTING LOOP" );
+  // Main Thread Loop
+  while( true )
+  {
+    if( ! connection->recvMsg( serverCmd ) )
+    {
+      writeOnLog( "P2P Thread: Unable to receive the command from BG" );
+
+      // TODO : Check here
+      if( serverCmd != "SHUTDOWN" )
+        continue;
+    }
+
+    command = "";
+    event   = EV_NONE;
+    if( ! serverCmd.compare( 0, 4, "PLAY" ) )
+    {
+      command = serverCmd.substr( 5 );
+      event = EV_PLAY;
+    }
+    else if ( ! serverCmd.compare( 0, 5, "PAUSE" ) )
+    {
+      event = EV_PAUSE;
+    }
+    else if ( ! serverCmd.compare( 0, 6, "RESUME" ) )
+    {
+      event = EV_RESUME;
+    }
+    else if ( ! serverCmd.compare( 0, 8, "SHUTDOWN" ) )
+    {
+      writeOnLog( "P2P Thread: Received SHUTDOWN" );
+      event = EV_CLOSE;
+    }
+    else if ( ! serverCmd.compare( 0, 4, "INFO" ) )
+    {
+      command = serverCmd.substr( 5 );
+      event = EV_INFO;
+      writeOnLog( "INFO command received: %s", command.c_str() );
+    }
+    else
+    {
+      writeOnLog( "P2P Thread: Received wrong command: %s", serverCmd.c_str() );
+      continue;
+    }
+
+    writeOnLog( "P2P Thread: Command: %s", command.c_str() );
+
+    if( WaitForSingleObject( *syncMutex, INFINITE ) == WAIT_FAILED )
+    { writeOnLog( "Failed to Lock the Mutex" ); continue; }
+
+    // Call all event handlers related to the event
+    equalEventsIt = eventMap->equal_range( event );
+    for( eventIt = equalEventsIt.first; eventIt != equalEventsIt.second; ++eventIt )
+      ( (*eventIt).second )->process( command.c_str() );
+
+    if( ! ReleaseMutex( *syncMutex ) )
+    { writeOnLog( "Failed to Release the Mutex" ); continue; }
+
+    if( event == EV_CLOSE )
+      break;
+  }
+  writeOnLog( "P2P Thread: EXITING Loop" );
+  SetEvent( *syncEvent ); // Main thread can shut down now
+  return 0;
+}
+
+///////////////////////////
+/*void P2PControl::unregEventCB( bg_event_t event, EventHandlerWrap * eventCallback )
+{
+  std::pair< event_cb_map_t::iterator, event_cb_map_t::iterator > equalEventsIt;
+  // TODO
+  if( WaitForSingleObject( mSyncMutex, INFINITE ) == WAIT_FAILED )
+  { writeOnLog( "Failed to Lock the Mutex" ); return; }
+
+  equalEventsIt = mEventCBMap->equal_range( event );
+  for( eventIt = equalEventsIt.first; eventIt != equalEventsIt.second; ++eventIt )
+    ( (*eventIt).second )->process( command.c_str() );
+
+  if( ! ReleaseMutex( mSyncMutex ) )
+  { writeOnLog( "Failed to Release the Mutex" ); return; }
+}*/
+
+///////////////////////////
+void P2PControl::unregEventCB( bg_event_t event )
+{
+  if( WaitForSingleObject( mSyncMutex, INFINITE ) == WAIT_FAILED )
+  { writeOnLog( "Failed to Lock the Mutex" ); return; }
+
+  mEventCBMap.erase( event );
+
+  if( ! ReleaseMutex( mSyncMutex ) )
+  { writeOnLog( "Failed to Release the Mutex" ); return; }
+}
+
Index: projects/activex/axvlc.idl
===================================================================
--- projects/activex/axvlc.idl	(.../trunk)	(revision 13995)
+++ projects/activex/axvlc.idl	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -216,8 +216,8 @@
 
     [
       odl,
-      uuid(49E0DBD1-9440-466C-9C97-95C67190C603),
-      helpstring("VLC Input APIs"),
+	  uuid(A1F85300-9D3F-11DE-AF38-0002A5D5C51B), // P2P-Next, new UUID
+      helpstring("P2P-Next extended VLC Input APIs"),
       dual,
       oleautomation
     ]
@@ -249,6 +249,10 @@
 
         [propget, helpstring("Returns whether current playback displays video.")]
         HRESULT hasVout([out, retval] VARIANT_BOOL* hasVout);
+
+		// P2P-Next
+        [propget, helpstring("Returns last NSSA INFO message")]
+        HRESULT p2pstatus([out, retval] BSTR* p2pstatus);
     };
 
     [
@@ -530,7 +534,7 @@
     };
 
     [
-      uuid(E23FE9C6-778E-49D4-B537-38FCDE4887D8),
+      uuid(045E7BEE-6F8F-44cf-AFF1-52710C6209FE),
       helpstring("VLC control (deprecated)"),
       control
     ]
@@ -542,8 +546,9 @@
     };
 
     [
-      uuid(9BE31822-FDAD-461B-AD51-BE1D1C159921),
-      helpstring("VLC control"),
+      uuid(1800B8AF-4E33-43C0-AFC7-894433C13538),
+
+      helpstring("SwarmPlugin control"),
       control
     ]
     coclass VLCPlugin2
Index: projects/activex/vlccontrol2.cpp
===================================================================
--- projects/activex/vlccontrol2.cpp	(.../trunk)	(revision 13995)
+++ projects/activex/vlccontrol2.cpp	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -646,6 +646,26 @@
     return hr;
 };
 
+
+// P2P-Next
+STDMETHODIMP VLCInput::get_p2pstatus(BSTR *p2pstatus)
+{
+    if( NULL == p2pstatus )
+        return E_POINTER;
+
+    const char *p2pstatusStr = _p_instance->getP2PStatus();
+    if( NULL != p2pstatusStr )
+    {
+        *p2pstatus = BSTRFromCStr(CP_UTF8, p2pstatusStr);
+
+        return (NULL == *p2pstatus) ? E_OUTOFMEMORY : NOERROR;
+    }
+    *p2pstatus = NULL;
+    return E_FAIL;
+};
+
+
+
 /*******************************************************************************/
 
 VLCLog::~VLCLog()
Index: projects/activex/axvlc.dll.manifest
===================================================================
--- projects/activex/axvlc.dll.manifest	(.../trunk)	(revision 13995)
+++ projects/activex/axvlc.dll.manifest	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -1,10 +1,10 @@
 <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
 <assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
 	<assemblyIdentity
-		version="1.0.0.0"
+		version="1.0.3.0"
 		processorArchitecture="x86"
 		name="axvlc.dll"
 		type="win32"
 	/>
-	<description>VLC ActiveX plugin</description>
+	<description>SwarmPlugin P2P Multimedia ActiveX plugin</description>
 </assembly>
Index: projects/activex/axvlc.inf.in
===================================================================
--- projects/activex/axvlc.inf.in	(.../trunk)	(revision 13995)
+++ projects/activex/axvlc.inf.in	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -1,4 +1,6 @@
 ; Version number and signature of INF file.
+; Written by Diego Andres Rabaioli
+; see LICENSE.txt for license information
 ;
 [version]
   signature="$CHICAGO$"
@@ -6,18 +8,17 @@
 
 [Add.Code]
   axvlc.dll=axvlc.dll
-  vlc-@VERSION@-win32.exe=vlc-@VERSION@-win32.exe
+  SwarmPlugin_1.0.3.exe=SwarmPlugin_1.0.3.exe
 
 [axvlc.dll]
-  FileVersion=@VERSION_MAJOR@,@VERSION_MINOR@,@VERSION_REVISION@,0
-  clsid={9BE31822-FDAD-461B-AD51-BE1D1C159921}
+  FileVersion=1.0.3,0
+  clsid={1800B8AF-4E33-43C0-AFC7-894433C13538}
   RegisterServer=no
   Hook=runinstaller
 
-[vlc-@VERSION@-win32.exe]
-  FileVersion=@VERSION_MAJOR@,@VERSION_MINOR@,@VERSION_REVISION@,0
-  file-win32-x86=http://downloads.videolan.org/pub/videolan/vlc/@VERSION@/win32/vlc-@VERSION@-win32.exe
+[SwarmPlugin_1.0.3.exe]
+  FileVersion=1.0.3,0
+  file-win32-x86=http://trial.p2p-next.org/Beta/SwarmPlugin_1.0.3.exe
 
 [runinstaller]
-  run=%EXTRACT_DIR%\vlc-@VERSION@-win32.exe
-
+  run=%EXTRACT_DIR%\SwarmPlugin_1.0.3.exe
Index: projects/activex/main.cpp
===================================================================
--- projects/activex/main.cpp	(.../trunk)	(revision 13995)
+++ projects/activex/main.cpp	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -34,9 +34,9 @@
 
 using namespace std;
 
-#define COMPANY_STR "VideoLAN"
-#define PROGRAM_STR "VLCPlugin"
-#define DESCRIPTION "VideoLAN VLC ActiveX Plugin"
+#define COMPANY_STR "P2PNext"
+#define PROGRAM_STR "SwarmPlugin"
+#define DESCRIPTION "SwarmPlayer ActiveX Plugin"
 
 #define THREADING_MODEL "Apartment"
 #define MISC_STATUS     "131473"
Index: projects/activex/axvlc_rc.rc.in
===================================================================
--- projects/activex/axvlc_rc.rc.in	(.../trunk)	(revision 13995)
+++ projects/activex/axvlc_rc.rc.in	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -1,4 +1,4 @@
-#define VERSION_NUMBER @VERSION_MAJOR@,@VERSION_MINOR@,@VERSION_REVISION@,@VERSION_EXTRA_RC@
+#define VERSION_NUMBER 1,0,3,0
 
 1 BITMAP "vlc16x16.bmp"
 1 VERSIONINFO
@@ -11,10 +11,10 @@
   BEGIN
     BLOCK "040904E4"
     BEGIN
-      VALUE "CompanyName", "the VideoLAN Team"
-      VALUE "FileVersion", "@VERSION@"
-      VALUE "FileDescription", "VLC media player (Activex Plugin)"
-      VALUE "LegalCopyright", "(c) @COPYRIGHT_YEARS@ the VideoLAN Team"
+      VALUE "CompanyName", "the VideoLAN Team and P2P-Next project"
+      VALUE "FileVersion", "1.0.3"
+      VALUE "FileDescription", "SwarmPlugin Version 1.0.3, Copyright (c) 2009, the VideoLAN Team and Delft University of Technology<br><a href=""http://www.pds.ewi.tudelft.nl/code.html"">http://www.pds.ewi.tudelft.nl/code.html</a>"
+      VALUE "LegalCopyright", "Copyright \251 2009 the VideoLAN Team and Delft University of Technology"
       VALUE "OLESelfRegister", "\0"
     END
   END
Index: projects/activex/README.TXT
===================================================================
--- projects/activex/README.TXT	(.../trunk)	(revision 13995)
+++ projects/activex/README.TXT	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -20,6 +20,12 @@
 axvlc_idl.h
 axvlc.tlb
 
+Arno: Open Visual Studio 2008 Command Prompt via Start Menu. Then run:
+
+C:> midl /h axvlc_idl.h /iid axvlc_idl.c axvlc.idl
+
+ArnoEnd.
+
 To use the MIDL compiler on cygwin, you will need to set some environment variables
 before configuring vlc. If you have a copy of 'Microsoft Visual C++ 6.0' installed,
 the following settings are correct:
Index: projects/activex/plugin.h
===================================================================
--- projects/activex/plugin.h	(.../trunk)	(revision 13995)
+++ projects/activex/plugin.h	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -28,6 +28,13 @@
 
 #include <vlc/vlc.h>
 
+// P2P-Next
+#define _MEDIACONTROL_ 0
+#if _MEDIACONTROL_
+// TODO : just for test
+#include <vlc/mediacontrol.h>
+#endif
+
 extern "C" const GUID CLSID_VLCPlugin;
 extern "C" const GUID CLSID_VLCPlugin2;
 extern "C" const GUID LIBID_AXVLC;
@@ -237,6 +244,14 @@
     void fireOnPauseEvent(void);
     void fireOnStopEvent(void);
 
+    // P2P-Next
+    /* P2P Event Handlers */
+    void onPlay  ( const char * stream );
+    void onPause ( const char * nothing );
+    void onResume( const char * nothing );
+    void onStop  ( const char * nothing );
+    void onInfo  ( const char * string );
+
     // controlling IUnknown interface
     LPUNKNOWN pUnkOuter;
 
@@ -307,6 +322,10 @@
             libvlc_media_player_play(_p_mplayer,ex);
     }
 
+    // For JavaScript API
+    const char *       getP2PStatus();
+
+
 protected:
 
     virtual ~VLCPlugin();
@@ -333,6 +352,13 @@
     class VLCDataObject *vlcDataObject;
     class VLCSupportErrorInfo *vlcSupportErrorInfo;
 
+    // P2P-Next
+    class P2PControl  * p2pControl;
+    char * p2pStatus;
+#if _MEDIACONTROL_
+    mediacontrol_Instance * mediaControl;
+#endif
+
     // in place activated window (Plugin window)
     HWND _inplacewnd;
 
Index: projects/activex/axvlc_idl.c
===================================================================
--- projects/activex/axvlc_idl.c	(.../trunk)	(revision 13995)
+++ projects/activex/axvlc_idl.c	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -6,7 +6,7 @@
 
 
  /* File created by MIDL compiler version 7.00.0500 */
-/* at Fri Apr 25 11:37:37 2008
+/* at Wed Sep 09 17:04:44 2009
  */
 /* Compiler settings for axvlc.idl:
     Oicf, W1, Zp8, env=Win32 (32b run)
@@ -76,7 +76,7 @@
 MIDL_DEFINE_GUID(IID, IID_IVLCAudio,0x9E0BD17B,0x2D3C,0x4656,0xB9,0x4D,0x03,0x08,0x4F,0x3F,0xD9,0xD4);
 
 
-MIDL_DEFINE_GUID(IID, IID_IVLCInput,0x49E0DBD1,0x9440,0x466C,0x9C,0x97,0x95,0xC6,0x71,0x90,0xC6,0x03);
+MIDL_DEFINE_GUID(IID, IID_IVLCInput,0xA1F85300,0x9D3F,0x11DE,0xAF,0x38,0x00,0x02,0xA5,0xD5,0xC5,0x1B);
 
 
 MIDL_DEFINE_GUID(IID, IID_IVLCLog,0x8E3BC3D9,0x62E9,0x48FB,0x8A,0x6D,0x99,0x3F,0x9A,0xBC,0x4A,0x0A);
@@ -106,10 +106,10 @@
 MIDL_DEFINE_GUID(IID, IID_IVLCPlaylistItems,0xFD37FE32,0x82BC,0x4A25,0xB0,0x56,0x31,0x5F,0x4D,0xBB,0x19,0x4D);
 
 
-MIDL_DEFINE_GUID(CLSID, CLSID_VLCPlugin,0xE23FE9C6,0x778E,0x49D4,0xB5,0x37,0x38,0xFC,0xDE,0x48,0x87,0xD8);
+MIDL_DEFINE_GUID(CLSID, CLSID_VLCPlugin,0x045E7BEE,0x6F8F,0x44cf,0xAF,0xF1,0x52,0x71,0x0C,0x62,0x09,0xFE);
 
 
-MIDL_DEFINE_GUID(CLSID, CLSID_VLCPlugin2,0x9BE31822,0xFDAD,0x461B,0xAD,0x51,0xBE,0x1D,0x1C,0x15,0x99,0x21);
+MIDL_DEFINE_GUID(CLSID, CLSID_VLCPlugin2,0x1800B8AF,0x4E33,0x43C0,0xAF,0xC7,0x89,0x44,0x33,0xC1,0x35,0x38);
 
 #undef MIDL_DEFINE_GUID
 
Index: projects/activex/p2pcontrol.h
===================================================================
--- projects/activex/p2pcontrol.h	(.../trunk)	(revision 0)
+++ projects/activex/p2pcontrol.h	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,202 @@
+/* 
+ * Written by Diego Andres Rabaioli
+ * see P2P-Next-LICENSE.txt for license information
+ */
+
+
+#ifndef _P2PCONTROL_H
+#define _P2PCONTROL_H
+
+#include <winsock2.h>
+#include <string>
+#include <map>
+
+
+////////////////////////
+//
+// The P2PControl class handles the communicaion with the BG Process.
+// Through P2PControl it's possible to send requests to the BG like
+// 'START myvideo.torrent' and accept commands like 'PLAY', 'PAUSE',...
+// It's possible to associate an action to each BG command, registering
+// a callback related to the specific event:
+// regEventCB( EV_PLAY, myCallbackFunction );
+//
+// General use case:
+//
+// P2PControl * p2pControl = new P2PControl();
+// if( ! p2pControl->startup() )
+//   return -1;
+//
+// p2pControl->regEventCB( EV_PLAY,   &myPlayHandler );
+// p2pControl->regEventCB( EV_PAUSE,  &myPauseHandler );
+// p2pControl->regEventCB( EV_RESUME, &myResumeHandler );
+// ...
+//
+// if( ! p2pControl->sendTorrent( 'http://www.foo.com/videocontent_1.torrent' ) )
+//  return -1;
+//
+////////////////////////
+
+void writeOnLog( const char * msg, ... );
+
+///////////////////////////
+// BGPConnection
+///////////////////////////
+
+// States enumerations
+enum sock_state_t { S_DOWN, S_STARTED, S_CREATED, S_UP };
+
+const int         IN_BUF_LEN = 512;
+const int         BG_PORT    = 62062;
+const std::string BG_ADDRESS = "127.0.0.1";
+
+class BGPConnection
+{
+ public:
+  BGPConnection( const int port, const std::string bgAddress );
+  ~BGPConnection();
+
+  bool connect();
+  bool disconnect();
+
+  bool sendMsg( const std::string & ) const;
+  bool recvMsg( std::string & ) const;
+
+  std::string  getAddress() { return mBGAddress; }
+  int          getPort()    { return mPort; }
+
+ private:
+  SOCKET       mServerSocket;
+  std::string  mBGAddress;
+  int          mPort;
+  sock_state_t mSocketState;
+};
+
+///////////////////////////
+// EventHandlerWrap
+///////////////////////////
+class EventHandlerWrap
+{
+ public:
+  virtual void process( const char * ) const = 0;
+  virtual ~EventHandlerWrap() {}
+};
+
+///////////////////////////
+class EventHandlerWrap_Static : public EventHandlerWrap
+{
+ public:
+  EventHandlerWrap_Static( void ( *handler )( const char * ) ):
+    mSHandler( handler ) {}
+
+  virtual ~EventHandlerWrap_Static() {}
+
+  virtual void process( const char * c ) const
+  {
+    mSHandler( c );
+  }
+
+ private:
+  void ( *mSHandler )( const char * );
+
+};
+
+///////////////////////////
+template < class T >
+class EventHandlerWrap_NonStatic : public EventHandlerWrap
+{
+ public:
+  EventHandlerWrap_NonStatic( T * obj, void ( T::* handler )( const char * ) ):
+    mObject( obj ), mNHandler( handler ) {}
+
+  virtual ~EventHandlerWrap_NonStatic() {}
+
+  virtual void process( const char * c ) const
+  {
+    (mObject->*mNHandler)( c );
+  }
+
+ private:
+  T * mObject;
+  void ( T::* mNHandler )( const char * );
+};
+
+///////////////////////////
+// P2PControl
+///////////////////////////
+
+// Constants
+const WCHAR PLUGIN_REG_KEY[]   = L"Software\\SwarmPlugin";
+const WCHAR BG_PATH_ELEMENT[]  = L"BGProcessPath";
+const WCHAR LOG_PATH_ELEMENT[] = L"InstallDir";
+const char  LOG_FILE_NAME[]    = "swarmplugin.log";
+
+// Event Callback types
+enum bg_event_t { EV_NONE, EV_PLAY, EV_PAUSE, EV_RESUME, EV_STOP, EV_INFO, EV_CLOSE };
+typedef std::multimap< bg_event_t, EventHandlerWrap * > event_cb_map_t;
+typedef std::pair< bg_event_t, EventHandlerWrap * >     event_cb_item_t;
+
+// States enumerations
+enum protocol_status_t { P_DOWN, P_UP, P_CLOSING };
+
+class P2PControl
+{
+ public:
+  P2PControl( const int port = BG_PORT, const std::string bgAddress = BG_ADDRESS );
+  ~P2PControl();
+
+  bool  startup();
+  bool  shutdown();
+
+  bool  launchBGProcess( const char * cmd = NULL );
+  bool  sendTorrent( const std::string torrent );
+
+  void  regEventCB( bg_event_t event, void (*callback)( const char * ) )
+  {
+    if( WaitForSingleObject( mSyncMutex, INFINITE ) == WAIT_FAILED )
+      { writeOnLog( "Failed to Lock the Mutex" ); return; }
+
+    EventHandlerWrap * wrap = new EventHandlerWrap_Static( callback );
+    mEventCBMap.insert( event_cb_item_t( event, wrap ) );
+
+    if( ! ReleaseMutex( mSyncMutex ) )
+      { writeOnLog( "Failed to Release the Mutex" ); return; }
+  }
+
+  template < class T >
+  void  regEventCB( bg_event_t event, T * obj, void ( T::* callback)( const char * ) )
+  {
+    if( WaitForSingleObject( mSyncMutex, INFINITE ) == WAIT_FAILED )
+      { writeOnLog( "Failed to Lock the Mutex" ); return; }
+
+    EventHandlerWrap * wrap = new EventHandlerWrap_NonStatic< T >( obj, callback );
+    mEventCBMap.insert( event_cb_item_t( event, wrap ) ); 
+
+    if( ! ReleaseMutex( mSyncMutex ) )
+      { writeOnLog( "Failed to Release the Mutex" ); return; }
+  }
+
+  //void  unregEventCB( bg_event_t, EventHandlerWrap * );
+  void  unregEventCB( bg_event_t );
+
+ private:
+  // Thread utilities
+  const BGPConnection *  getConnection() const { return mConnection; }
+  const event_cb_map_t * getEventMap()   const { return &mEventCBMap; }
+  // Event Loop: receives events from BG and call the registered handlers
+  static DWORD WINAPI    eventLoop( LPVOID );
+  // Back Ground Process
+  static bool            startBGProcess();
+
+  // Variable Members
+  BGPConnection *   mConnection;
+  protocol_status_t mProtoState;
+
+  // Thread and Sync
+  event_cb_map_t    mEventCBMap;  // Association event/callback
+  HANDLE            mEventThread; // Thread handler
+  HANDLE            mSyncEvent;   // Syncronize the thread at startup and shutdown time
+  HANDLE            mSyncMutex;   // Syncronize access to the Event Map
+};
+
+#endif  // _P2PCONTROL_H
Index: projects/activex/axvlc_idl.h
===================================================================
--- projects/activex/axvlc_idl.h	(.../trunk)	(revision 13995)
+++ projects/activex/axvlc_idl.h	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -4,7 +4,7 @@
 
 
  /* File created by MIDL compiler version 7.00.0500 */
-/* at Fri Apr 25 11:37:37 2008
+/* at Wed Sep 09 17:04:44 2009
  */
 /* Compiler settings for axvlc.idl:
     Oicf, W1, Zp8, env=Win32 (32b run)
@@ -852,7 +852,7 @@
 
 #if defined(__cplusplus) && !defined(CINTERFACE)
     
-    MIDL_INTERFACE("49E0DBD1-9440-466C-9C97-95C67190C603")
+    MIDL_INTERFACE("A1F85300-9D3F-11DE-AF38-0002A5D5C51B")
     IVLCInput : public IDispatch
     {
     public:
@@ -886,6 +886,9 @@
         virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasVout( 
             /* [retval][out] */ VARIANT_BOOL *hasVout) = 0;
         
+        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_p2pstatus( 
+            /* [retval][out] */ BSTR *p2pstatus) = 0;
+        
     };
     
 #else 	/* C style interface */
@@ -975,6 +978,10 @@
             IVLCInput * This,
             /* [retval][out] */ VARIANT_BOOL *hasVout);
         
+        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_p2pstatus )( 
+            IVLCInput * This,
+            /* [retval][out] */ BSTR *p2pstatus);
+        
         END_INTERFACE
     } IVLCInputVtbl;
 
@@ -1041,6 +1048,9 @@
 #define IVLCInput_get_hasVout(This,hasVout)	\
     ( (This)->lpVtbl -> get_hasVout(This,hasVout) ) 
 
+#define IVLCInput_get_p2pstatus(This,p2pstatus)	\
+    ( (This)->lpVtbl -> get_p2pstatus(This,p2pstatus) ) 
+
 #endif /* COBJMACROS */
 
 
@@ -2171,12 +2181,6 @@
         virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MRL( 
             /* [in] */ BSTR mrl) = 0;
         
-        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Toolbar( 
-            /* [retval][out] */ VARIANT_BOOL *visible) = 0;
-        
-        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Toolbar( 
-            /* [in] */ VARIANT_BOOL visible) = 0;
-        
         virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_VersionInfo( 
             /* [retval][out] */ BSTR *version) = 0;
         
@@ -2198,6 +2202,12 @@
         virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
             /* [in] */ OLE_COLOR backcolor) = 0;
         
+        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Toolbar( 
+            /* [retval][out] */ VARIANT_BOOL *visible) = 0;
+        
+        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Toolbar( 
+            /* [in] */ VARIANT_BOOL visible) = 0;
+        
         virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_audio( 
             /* [retval][out] */ IVLCAudio **obj) = 0;
         
@@ -2302,14 +2312,6 @@
             IVLCControl2 * This,
             /* [in] */ BSTR mrl);
         
-        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Toolbar )( 
-            IVLCControl2 * This,
-            /* [retval][out] */ VARIANT_BOOL *visible);
-        
-        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Toolbar )( 
-            IVLCControl2 * This,
-            /* [in] */ VARIANT_BOOL visible);
-        
         /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VersionInfo )( 
             IVLCControl2 * This,
             /* [retval][out] */ BSTR *version);
@@ -2338,6 +2340,14 @@
             IVLCControl2 * This,
             /* [in] */ OLE_COLOR backcolor);
         
+        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Toolbar )( 
+            IVLCControl2 * This,
+            /* [retval][out] */ VARIANT_BOOL *visible);
+        
+        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Toolbar )( 
+            IVLCControl2 * This,
+            /* [in] */ VARIANT_BOOL visible);
+        
         /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_audio )( 
             IVLCControl2 * This,
             /* [retval][out] */ IVLCAudio **obj);
@@ -2424,12 +2434,6 @@
 #define IVLCControl2_put_MRL(This,mrl)	\
     ( (This)->lpVtbl -> put_MRL(This,mrl) ) 
 
-#define IVLCControl2_get_Toolbar(This,visible)	\
-    ( (This)->lpVtbl -> get_Toolbar(This,visible) ) 
-
-#define IVLCControl2_put_Toolbar(This,visible)	\
-    ( (This)->lpVtbl -> put_Toolbar(This,visible) ) 
-
 #define IVLCControl2_get_VersionInfo(This,version)	\
     ( (This)->lpVtbl -> get_VersionInfo(This,version) ) 
 
@@ -2451,6 +2455,12 @@
 #define IVLCControl2_put_BackColor(This,backcolor)	\
     ( (This)->lpVtbl -> put_BackColor(This,backcolor) ) 
 
+#define IVLCControl2_get_Toolbar(This,visible)	\
+    ( (This)->lpVtbl -> get_Toolbar(This,visible) ) 
+
+#define IVLCControl2_put_Toolbar(This,visible)	\
+    ( (This)->lpVtbl -> put_Toolbar(This,visible) ) 
+
 #define IVLCControl2_get_audio(This,obj)	\
     ( (This)->lpVtbl -> get_audio(This,obj) ) 
 
@@ -2727,7 +2737,7 @@
 
 #ifdef __cplusplus
 
-class DECLSPEC_UUID("E23FE9C6-778E-49D4-B537-38FCDE4887D8")
+class DECLSPEC_UUID("045E7BEE-6F8F-44cf-AFF1-52710C6209FE")
 VLCPlugin;
 #endif
 
@@ -2735,7 +2745,7 @@
 
 #ifdef __cplusplus
 
-class DECLSPEC_UUID("9BE31822-FDAD-461B-AD51-BE1D1C159921")
+class DECLSPEC_UUID("1800B8AF-4E33-43C0-AFC7-894433C13538")
 VLCPlugin2;
 #endif
 #endif /* __AXVLC_LIBRARY_DEFINED__ */
Index: projects/activex/vlccontrol2.h
===================================================================
--- projects/activex/vlccontrol2.h	(.../trunk)	(revision 13995)
+++ projects/activex/vlccontrol2.h	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -126,6 +126,7 @@
     STDMETHODIMP put_rate(double);
     STDMETHODIMP get_fps(double*);
     STDMETHODIMP get_hasVout(VARIANT_BOOL*);
+    STDMETHODIMP get_p2pstatus(BSTR *version); 
 
 protected:
     HRESULT loadTypeInfo();
Index: projects/activex/Makefile.am
===================================================================
--- projects/activex/Makefile.am	(.../trunk)	(revision 13995)
+++ projects/activex/Makefile.am	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -42,6 +42,8 @@
     vlccontrol2.h \
     plugin.cpp \
     plugin.h \
+    p2pcontrol.cpp \
+    p2pcontrol.h \
     axvlc_idl.c \
     axvlc_idl.h \
     guiddef.h \
@@ -75,7 +77,7 @@
 axvlc_la_CXXFLAGS = `$(VLC_CONFIG) --cxxflags activex`
 axvlc_la_DEPENDENCIES = axvlc.def $(DATA_axvlc_rc) $(LIBRARIES_libvlc)
 axvlc_la_LDFLAGS = -Wl,$(srcdir)/axvlc.def -Wl,$(DATA_axvlc_rc) \
-    -no-undefined -avoid-version -module \
+    -no-undefined -avoid-version -module -lws2_32 \
     `$(VLC_CONFIG) --ldflags activex libvlc`
 axvlc_la_LIBADD = $(LIBRARIES_libvlc) \
 	`$(VLC_CONFIG) -libs activex`
Index: projects/mozilla/control/npolibvlc.cpp
===================================================================
--- projects/mozilla/control/npolibvlc.cpp	(.../trunk)	(revision 13995)
+++ projects/mozilla/control/npolibvlc.cpp	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -369,6 +369,7 @@
     "rate",
     "fps",
     "hasVout",
+    "p2pstatus", //P2P-Next
 };
 COUNTNAMES(LibvlcInputNPObject,propertyCount,propertyNames);
 
@@ -381,6 +382,7 @@
     ID_input_rate,
     ID_input_fps,
     ID_input_hasvout,
+    ID_input_p2pstatus, //P2P-Next
 };
 
 RuntimeNPObject::InvokeResult
@@ -396,19 +398,23 @@
         libvlc_media_player_t *p_md = p_plugin->getMD(&ex);
         if( libvlc_exception_raised(&ex) )
         {
-            if( index != ID_input_state )
+	    if( index == ID_input_p2pstatus )
             {
-                NPN_SetException(this, libvlc_exception_get_message(&ex));
-                libvlc_exception_clear(&ex);
-                return INVOKERESULT_GENERIC_ERROR;
+		return this->getP2PStatus(result);
             }
-            else
+            else if( index == ID_input_state )
             {
                 /* for input state, return CLOSED rather than an exception */
                 INT32_TO_NPVARIANT(0, result);
                 libvlc_exception_clear(&ex);
                 return INVOKERESULT_NO_ERROR;
             }
+	    else
+            {
+                NPN_SetException(this, libvlc_exception_get_message(&ex));
+                libvlc_exception_clear(&ex);
+                return INVOKERESULT_GENERIC_ERROR;
+            }
         }
 
         switch( index )
@@ -462,6 +468,10 @@
                 BOOLEAN_TO_NPVARIANT(val, result);
                 return INVOKERESULT_NO_ERROR;
             }
+            case ID_input_p2pstatus: //P2P-Next
+            {
+		return this->getP2PStatus(result);
+            }
             default:
                 ;
         }
@@ -469,7 +479,29 @@
     return INVOKERESULT_GENERIC_ERROR;
 }
 
+//P2P-Next
 RuntimeNPObject::InvokeResult
+LibvlcInputNPObject::getP2PStatus(NPVariant &result)
+{
+    VlcPlugin* p_plugin = getPrivate<VlcPlugin>();
+#ifdef XP_WIN
+    const char *s = p_plugin->getP2PStatus();
+    int len = strlen(s);
+    NPUTF8 *retval =(NPUTF8*)NPN_MemAlloc(len);
+    if( !retval )
+        return INVOKERESULT_OUT_OF_MEMORY;
+
+    memcpy(retval, s, len);
+    STRINGN_TO_NPVARIANT(retval, len, result);
+    return INVOKERESULT_NO_ERROR;
+#else
+    return INVOKERESULT_GENERIC_ERROR;
+#endif
+}
+
+
+
+RuntimeNPObject::InvokeResult
 LibvlcInputNPObject::setProperty(int index, const NPVariant &value)
 {
     /* is plugin still running */
Index: projects/mozilla/control/npolibvlc.h
===================================================================
--- projects/mozilla/control/npolibvlc.h	(.../trunk)	(revision 13995)
+++ projects/mozilla/control/npolibvlc.h	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -99,6 +99,9 @@
     static const NPUTF8 * const methodNames[];
 
     InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
+//P2P-Next
+private:
+    InvokeResult getP2PStatus(NPVariant &result);
 };
 
 class LibvlcPlaylistItemsNPObject: public RuntimeNPObject
Index: projects/mozilla/npvlc.dll.manifest
===================================================================
--- projects/mozilla/npvlc.dll.manifest	(.../trunk)	(revision 13995)
+++ projects/mozilla/npvlc.dll.manifest	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -1,10 +1,10 @@
 <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
 <assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
 	<assemblyIdentity
-		version="1.0.0.0"
+		version="1.0.3.0"
 		processorArchitecture="x86"
 		name="npvlc.dll"
 		type="win32"
 	/>
-	<description>VLC Mozilla plugin</description>
-</assembly>
\ No newline at end of file
+	<description>SwarmPlugin P2P Multimedia Mozilla plugin</description>
+</assembly>
Index: projects/mozilla/Makefile.in
===================================================================
--- projects/mozilla/Makefile.in	(.../trunk)	(revision 13995)
+++ projects/mozilla/Makefile.in	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -73,9 +73,10 @@
 	vlcplugin.cpp vlcplugin.h control/npolibvlc.cpp \
 	control/npolibvlc.h control/nporuntime.cpp \
 	control/nporuntime.h support/classinfo.h support/npunix.c \
-	support/npmac.cpp support/npwin.cpp
+	support/npmac.cpp support/npwin.cpp \
+	p2pcontrol.cpp p2pcontrol.h
 am__objects_1 = libvlcplugin_la-vlcshell.lo \
-	libvlcplugin_la-vlcplugin.lo libvlcplugin_la-npolibvlc.lo \
+	libvlcplugin_la-vlcplugin.lo libvlcplugin_la-p2pcontrol.lo libvlcplugin_la-npolibvlc.lo \
 	libvlcplugin_la-nporuntime.lo
 @BUILD_MOZILLA_TRUE@@HAVE_DARWIN_FALSE@@HAVE_WIN32_FALSE@am__objects_2 = libvlcplugin_la-npunix.lo
 @BUILD_MOZILLA_TRUE@@HAVE_DARWIN_TRUE@@HAVE_WIN32_FALSE@am__objects_2 = libvlcplugin_la-npmac.lo
@@ -94,9 +95,10 @@
 	vlcplugin.h control/npolibvlc.cpp control/npolibvlc.h \
 	control/nporuntime.cpp control/nporuntime.h \
 	support/classinfo.h support/npunix.c support/npmac.cpp \
-	support/npwin.cpp
+	support/npwin.cpp \
+	p2pcontrol.cpp p2pcontrol.h
 am__objects_3 = npvlc_la-vlcshell.lo npvlc_la-vlcplugin.lo \
-	npvlc_la-npolibvlc.lo npvlc_la-nporuntime.lo
+	npvlc_la-p2pcontrol.lo npvlc_la-npolibvlc.lo npvlc_la-nporuntime.lo
 @BUILD_MOZILLA_TRUE@@HAVE_DARWIN_FALSE@@HAVE_WIN32_FALSE@am__objects_4 = npvlc_la-npunix.lo
 @BUILD_MOZILLA_TRUE@@HAVE_DARWIN_TRUE@@HAVE_WIN32_FALSE@am__objects_4 = npvlc_la-npmac.lo
 @BUILD_MOZILLA_TRUE@@HAVE_WIN32_TRUE@am__objects_4 =  \
@@ -898,6 +900,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libvlcplugin_la-npwin.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libvlcplugin_la-vlcplugin.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libvlcplugin_la-vlcshell.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libvlcplugin_la-p2pcontrol.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/npvlc_la-npmac.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/npvlc_la-npolibvlc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/npvlc_la-nporuntime.Plo@am__quote@
@@ -905,6 +908,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/npvlc_la-npwin.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/npvlc_la-vlcplugin.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/npvlc_la-vlcshell.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/npvlc_la-p2pcontrol.Plo@am__quote@
 
 .c.o:
 @am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
@@ -969,6 +973,15 @@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libvlcplugin_la_CXXFLAGS) $(CXXFLAGS) -c -o libvlcplugin_la-vlcshell.lo `test -f 'vlcshell.cpp' || echo '$(srcdir)/'`vlcshell.cpp
 
+
+libvlcplugin_la-p2pcontrol.lo: p2pcontrol.cpp
+@am__fastdepCXX_TRUE@	$(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libvlcplugin_la_CXXFLAGS) $(CXXFLAGS) -MT libvlcplugin_la-p2pcontrol.lo -MD -MP -MF $(DEPDIR)/libvlcplugin_la-p2pcontrol.Tpo -c -o libvlcplugin_la-p2pcontrol.lo `test -f 'p2pcontrol.cpp' || echo '$(srcdir)/'`p2pcontrol.cpp
+@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/libvlcplugin_la-p2pcontrol.Tpo $(DEPDIR)/libvlcplugin_la-p2pcontrol.Plo
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='p2pcontrol.cpp' object='libvlcplugin_la-p2pcontrol.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libvlcplugin_la_CXXFLAGS) $(CXXFLAGS) -c -o libvlcplugin_la-p2pcontrol.lo `test -f 'p2pcontrol.cpp' || echo '$(srcdir)/'`p2pcontrol.cpp
+
+
 libvlcplugin_la-vlcplugin.lo: vlcplugin.cpp
 @am__fastdepCXX_TRUE@	$(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libvlcplugin_la_CXXFLAGS) $(CXXFLAGS) -MT libvlcplugin_la-vlcplugin.lo -MD -MP -MF $(DEPDIR)/libvlcplugin_la-vlcplugin.Tpo -c -o libvlcplugin_la-vlcplugin.lo `test -f 'vlcplugin.cpp' || echo '$(srcdir)/'`vlcplugin.cpp
 @am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/libvlcplugin_la-vlcplugin.Tpo $(DEPDIR)/libvlcplugin_la-vlcplugin.Plo
@@ -1011,6 +1024,15 @@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(npvlc_la_CXXFLAGS) $(CXXFLAGS) -c -o npvlc_la-vlcshell.lo `test -f 'vlcshell.cpp' || echo '$(srcdir)/'`vlcshell.cpp
 
+
+npvlc_la-p2pcontrol.lo: p2pcontrol.cpp
+@am__fastdepCXX_TRUE@	$(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(npvlc_la_CXXFLAGS) $(CXXFLAGS) -MT npvlc_la-p2pcontrol.lo -MD -MP -MF $(DEPDIR)/npvlc_la-p2pcontrol.Tpo -c -o npvlc_la-p2pcontrol.lo `test -f 'p2pcontrol.cpp' || echo '$(srcdir)/'`p2pcontrol.cpp
+@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/npvlc_la-p2pcontrol.Tpo $(DEPDIR)/npvlc_la-p2pcontrol.Plo
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='p2pcontrol.cpp' object='npvlc_la-p2pcontrol.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(npvlc_la_CXXFLAGS) $(CXXFLAGS) -c -o npvlc_la-p2pcontrol.lo `test -f 'p2pcontrol.cpp' || echo '$(srcdir)/'`p2pcontrol.cpp
+
+
 npvlc_la-vlcplugin.lo: vlcplugin.cpp
 @am__fastdepCXX_TRUE@	$(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(npvlc_la_CXXFLAGS) $(CXXFLAGS) -MT npvlc_la-vlcplugin.lo -MD -MP -MF $(DEPDIR)/npvlc_la-vlcplugin.Tpo -c -o npvlc_la-vlcplugin.lo `test -f 'vlcplugin.cpp' || echo '$(srcdir)/'`vlcplugin.cpp
 @am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/npvlc_la-vlcplugin.Tpo $(DEPDIR)/npvlc_la-vlcplugin.Plo
Index: projects/mozilla/p2pcontrol.cpp
===================================================================
--- projects/mozilla/p2pcontrol.cpp	(.../trunk)	(revision 0)
+++ projects/mozilla/p2pcontrol.cpp	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,518 @@
+/*
+ * Written by Diego Andres Rabaioli
+ * see P2P-Next-LICENSE.txt for license information
+ */
+#ifdef XP_WIN
+
+#include "p2pcontrol.h"
+#include <string>
+
+#define P_DEBUG
+
+#ifdef P_DEBUG
+#include <stdio.h>
+#include <stdarg.h>
+#endif
+
+void writeOnLog( const char * msg, ... )
+{
+#ifdef P_DEBUG
+  static std::string logPath = "";
+
+  if( logPath.empty() )
+  {
+    LONG   result;
+    HKEY   hKey;
+    CHAR   Logpath[256];
+    DWORD  bufLen = sizeof( Logpath );
+
+    // Look in the Windows registry for installation path
+    result = RegOpenKeyEx( HKEY_LOCAL_MACHINE, PLUGIN_REG_KEY, 0, KEY_QUERY_VALUE, &hKey );
+    if( result != ERROR_SUCCESS ) { RegCloseKey( hKey ); return; }
+    result = RegQueryValueEx( hKey, LOG_PATH_ELEMENT, NULL, NULL, (LPBYTE)Logpath, &bufLen);
+    if( result != ERROR_SUCCESS ) { RegCloseKey( hKey ); return; }
+    RegCloseKey( hKey );
+    logPath.assign( Logpath );
+    logPath.append( "\\" );
+    logPath.append( LOG_FILE_NAME );
+  }
+
+  if( ! logPath.empty() )
+  {
+    FILE * file;
+    file = fopen( logPath.c_str(), "a" );
+    if( file == NULL ) return;
+
+    va_list args;
+    va_start( args, msg );
+    vfprintf( file, msg, args );
+    va_end( args );
+    fputs( "\r\n", file );
+    fclose( file );
+  }
+
+/*  FILE * file;
+  file = fopen( "C:\\vlc_plugin_fx.log", "a" );
+  if( file == NULL ) return;
+
+  va_list args;
+  va_start( args, msg );
+  vfprintf( file, msg, args );
+  va_end( args );
+  fputs( "\r\n", file );
+  fclose( file );*/
+#endif
+};
+
+///////////////////////////
+// BGPConnection
+///////////////////////////
+BGPConnection::BGPConnection( const int port, const std::string bgAddress )
+{
+  mBGAddress   = bgAddress;
+  mPort        = port;
+  mSocketState = S_DOWN;
+}
+
+///////////////////////////
+BGPConnection::~BGPConnection()
+{
+  disconnect();
+}
+
+///////////////////////////
+bool BGPConnection::connect()
+{
+  WSADATA            wsaData;
+  struct sockaddr_in serverAddress;
+  int                iResult;
+
+  // Just to be in a consistent state
+  if( mSocketState == S_UP )
+    return true;
+  else if( mSocketState != S_DOWN )
+    disconnect();
+
+  // Init Winsock
+  iResult = WSAStartup( MAKEWORD( 2, 2 ), &wsaData );
+  if( iResult != 0 )
+    return disconnect();
+
+  mSocketState = S_STARTED;
+
+  // Create socket
+  if( ( mServerSocket = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP ) ) == INVALID_SOCKET )
+    return disconnect();
+
+  mSocketState = S_CREATED;
+
+  memset( &serverAddress, 0, sizeof( serverAddress ) );
+  serverAddress.sin_family      = AF_INET;
+  serverAddress.sin_port        = htons( mPort );
+  serverAddress.sin_addr.s_addr = inet_addr( mBGAddress.c_str() );
+
+  // Connect to the BG process server
+  if( ( ::connect( mServerSocket, (struct sockaddr *)&serverAddress,
+                 sizeof( serverAddress ) ) ) == SOCKET_ERROR )
+  {
+    #ifdef P_DEBUG
+    writeOnLog( "BGPConnection: Could not connect to server" );
+    writeOnLog( "%i Socket Server : %i Server Addres : %i", WSAGetLastError(), mServerSocket, serverAddress.sin_addr.s_addr );
+    #endif
+    return disconnect();
+  }
+
+  #ifdef P_DEBUG
+  writeOnLog( "BGPConnection: CONNECTED" );
+  #endif
+
+  mSocketState = S_UP;
+  return true;
+
+}
+
+///////////////////////////
+bool BGPConnection::disconnect()
+{
+// Shut down the connection depending on the state of the socket
+// It basically returns always false (stupid code optimization reasons)
+  #ifdef P_DEBUG_2
+  char * tmp_str = NULL;
+  sprintf( tmp_str, "BGPConnection: Shutting down connection from status %d", mSocketState );
+  writeOnLog( tmp_str );
+  #endif
+
+  if( mSocketState == S_DOWN )
+    return false;
+
+  if( mSocketState >= S_CREATED )
+  {
+    closesocket( mServerSocket );
+    mServerSocket = INVALID_SOCKET;
+  }
+
+  WSACleanup();
+  mSocketState = S_DOWN;
+  return false;
+}
+
+///////////////////////////
+bool BGPConnection::sendMsg( const std::string & event ) const
+{
+  int res;
+
+  // Check socket status
+  if( mSocketState != S_UP )
+    return false;
+
+  // Complete message
+  std::string msg = event + "\r\n";
+  // Send Event
+  res = send( mServerSocket, msg.c_str(), msg.length(), 0 );
+  #ifdef P_DEBUG
+  writeOnLog( "BGPConnection: Sending: %s", event.c_str() );
+  #endif
+  if( res == SOCKET_ERROR )
+  {
+    #ifdef P_DEBUG
+    writeOnLog( "BGPConnection: Error in sending event" );
+    #endif
+    return false;
+  }
+
+  return true;
+}
+
+///////////////////////////
+bool BGPConnection::recvMsg( std::string & msg ) const
+{
+  char inBuffer[ IN_BUF_LEN ];
+  int  res;
+
+  if( mSocketState != S_UP )
+    return false;
+
+  msg = "";
+  while( true )
+  {
+    res = recv( mServerSocket, inBuffer, IN_BUF_LEN, 0 );
+
+    if( res <= 0 )
+    {
+      #ifdef P_DEBUG
+      writeOnLog( "BGPConnection: Error in receiving stream" );
+      #endif
+      msg = "SHUTDOWN";
+      return false;
+    }
+
+    msg.append( inBuffer, res );
+    if( ! msg.compare( msg.size() - 2, 2, "\r\n" ) )
+      break;
+  }
+  // Trim "\r\n"
+  msg.erase( msg.size() - 2 );
+
+  #ifdef P_DEBUG
+  writeOnLog( "BGPConnection: RECEIVED : %s", msg.c_str() );
+  #endif
+
+  return true;
+}
+
+///////////////////////////
+// P2PControl
+///////////////////////////
+P2PControl::P2PControl( const int port, const std::string bgAddress ) :
+  mEventCBMap(), mProtoState( P_DOWN )
+{
+  mConnection  = new BGPConnection( port, bgAddress );
+  mEventThread = NULL;
+}
+
+///////////////////////////
+P2PControl::~P2PControl()
+{
+  shutdown();
+}
+
+///////////////////////////
+bool P2PControl::startup()
+{
+  writeOnLog( "P2PControl::starting up..." );
+
+  // Try to connect to the BG Process.
+  // If it doesn't succeed then try to
+  // start the BG Process and try to
+  // connect againg
+  if( mProtoState == P_UP )
+    return true;
+
+  if( ! mConnection->connect() )
+    if( ! startBGProcess() || ! mConnection->connect() )
+      return mConnection->disconnect();
+
+
+  if( mEventThread != NULL ) // TODO : confusing... fix startup procedure
+    return true;
+
+  // Init syncronization event
+  mSyncEvent = CreateEvent( NULL, false, false, NULL );
+  if( mSyncEvent == NULL )
+  {
+    writeOnLog( "P2PControl: Error in creating syncronization event" );
+    return false;
+  }
+
+  // Init syncronization mutex
+  mSyncMutex = CreateMutex( NULL, false, NULL );
+  if( mSyncMutex == NULL )
+  {
+    writeOnLog( "P2PControl: Error in creating syncronization mutex" );
+    return false;
+  }
+
+  // Start the Event Loop
+  ThreadParams * threadParams = new ThreadParams;
+  threadParams->connection    = mConnection;
+  threadParams->eventMap      = &mEventCBMap;
+  threadParams->syncEvent     = &mSyncEvent;
+  threadParams->syncMutex     = &mSyncMutex;
+
+  mEventThread = CreateThread( NULL,
+                               0,
+                               &eventLoop,
+                               threadParams,
+                               0,
+                               NULL );
+
+  if( mEventThread == NULL )
+  {
+    writeOnLog( "P2PControl: Could not start event loop thread" );
+    delete threadParams;
+    return false;
+  }
+
+  if( WaitForSingleObject( mSyncEvent, INFINITE ) != WAIT_OBJECT_0 )
+    writeOnLog( "Sync Error while Starting up the event thread" );
+
+  delete threadParams;
+
+  mProtoState = P_UP;
+
+  return true;
+}
+
+///////////////////////////
+bool P2PControl::shutdown()
+{
+  DWORD res;
+  mConnection->sendMsg( "SHUTDOWN" );
+  res = WaitForSingleObject( mSyncEvent, 2000 );
+  if( res == WAIT_TIMEOUT ) writeOnLog( "Sync Error while closing thread" );
+  else writeOnLog( "P2PControl: Thread cleanly exited" );
+
+  CloseHandle( mEventThread );
+  CloseHandle( mSyncEvent );
+  CloseHandle( mSyncMutex );
+  delete mConnection;
+  mProtoState = P_DOWN;
+
+  return true;
+}
+
+///////////////////////////
+bool P2PControl::startBGProcess()
+{
+  LONG         result;
+  HKEY         hKey;
+  CHAR         BGpath[256]; // TODO : Fix this
+  DWORD        bufLen = sizeof( BGpath );
+
+  // Look in the Windows registry to get the path of the BG
+  result = RegOpenKeyEx( HKEY_LOCAL_MACHINE, PLUGIN_REG_KEY, 0, KEY_QUERY_VALUE, &hKey );
+  if( result != ERROR_SUCCESS ) { RegCloseKey( hKey ); return false; }
+  result = RegQueryValueEx( hKey, BG_PATH_ELEMENT, NULL, NULL, (LPBYTE)BGpath, &bufLen);
+  if( result != ERROR_SUCCESS ) { RegCloseKey( hKey ); return false; }
+  RegCloseKey( hKey );
+
+  // Set up variables
+  STARTUPINFOA        startupInfo;
+  PROCESS_INFORMATION processInfo;
+  memset( &startupInfo, 0, sizeof( startupInfo ) );
+  memset( &processInfo, 0, sizeof( processInfo ) );
+  startupInfo.cb = sizeof( startupInfo );
+
+  writeOnLog( "Starting BG Process..." );
+  // Finally start the BG Process
+  bool started = CreateProcess( BGpath,
+                                NULL,
+                                NULL,
+                                NULL,
+                                false,
+                                CREATE_NO_WINDOW,
+                                NULL,
+                                NULL,
+                                &startupInfo,
+                                &processInfo );
+
+  // Wait the process to startup and send a 'startup' event
+  HANDLE startupEvent = CreateEvent( NULL, false, false, "startupEvent" );
+  if( startupEvent == NULL )
+  {
+    writeOnLog( "P2PControl: Error in creating syncronization event: Could not create BG Process" );
+    started = false;
+  }
+  else
+  {
+    if( started )
+    {
+      writeOnLog( "Waiting Startup event from BG" );
+      ::WaitForSingleObject( startupEvent, INFINITE );
+      writeOnLog( "BGProcess Created" );
+    }
+    else
+    {
+      writeOnLog( "Could not start BG Process" );
+      writeOnLog(  "Last Error code : %i", GetLastError() );
+    }
+
+    CloseHandle( startupEvent );
+  }
+
+  CloseHandle( processInfo.hProcess );
+  CloseHandle( processInfo.hThread );
+
+  return started;
+}
+
+///////////////////////////
+bool P2PControl::sendTorrent( const std::string torrent )
+{
+  #ifdef P_DEBUG_2
+  writeOnLog( "P2PControl: Sending Torrent..." );
+  #endif
+
+  // Send START command with the torrent
+  std::string command = "START " + torrent;
+  return mConnection->sendMsg( command );
+}
+
+///////////////////////////
+DWORD WINAPI P2PControl::eventLoop( LPVOID params )
+{
+  BGPConnection *          connection;
+  event_cb_map_t *         eventMap;
+  std::string              serverCmd, command;
+  bg_event_t               event;
+  event_cb_map_t::iterator eventIt;
+  HANDLE *                 syncEvent;
+  HANDLE *                 syncMutex;
+  // Just for iterating through the events
+  std::pair< event_cb_map_t::iterator, event_cb_map_t::iterator > equalEventsIt;
+
+  // Parse parameters
+  connection = ( (ThreadParams *)params )->connection;
+  eventMap   = ( (ThreadParams *)params )->eventMap;
+  syncEvent  = ( (ThreadParams *)params )->syncEvent;
+  syncMutex  = ( (ThreadParams *)params )->syncMutex;
+
+  SetEvent( *syncEvent ); // Main thread can delete ThreadParams now
+
+  writeOnLog( "P2P Thread: STARTING LOOP" );
+  // Main Thread Loop
+  while( true )
+  {
+    if( ! connection->recvMsg( serverCmd ) )
+    {
+      #ifdef P_DEBUG
+      writeOnLog( "P2P Thread: Unable to receive the command from BG" );
+      #endif
+      if( serverCmd != "SHUTDOWN" )
+        continue;
+    }
+
+    command = "";
+    event   = EV_NONE;
+    if( ! serverCmd.compare( 0, 4, "PLAY" ) )
+    {
+      command = serverCmd.substr( 5 );
+      event = EV_PLAY;
+    }
+    else if ( ! serverCmd.compare( 0, 5, "PAUSE" ) )
+    {
+      event = EV_PAUSE;
+    }
+    else if ( ! serverCmd.compare( 0, 6, "RESUME" ) )
+    {
+      event = EV_RESUME;
+    }
+    else if ( ! serverCmd.compare( 0, 8, "SHUTDOWN" ) )
+    {
+      writeOnLog( "P2P Thread: Received SHUTDOWN" );
+      event = EV_CLOSE;
+    }
+    else if ( ! serverCmd.compare( 0, 4, "INFO" ) )
+    {
+      command = serverCmd.substr( 5 );
+      event = EV_INFO;
+      writeOnLog( "INFO command received: %s", command.c_str() );
+    }
+    else
+    {
+      #ifdef P_DEBUG
+      writeOnLog( "P2P Thread: Received wrong command: %s", serverCmd.c_str() );
+      #endif
+      continue;
+    }
+
+    writeOnLog( "P2P Thread: Command: %s", command.c_str() );
+
+    // Call all event handlers
+    if( WaitForSingleObject( *syncMutex, INFINITE ) == WAIT_FAILED )
+    { writeOnLog( "Failed to Lock the Mutex" ); continue; }
+
+    equalEventsIt = eventMap->equal_range( event );
+    for( eventIt = equalEventsIt.first; eventIt != equalEventsIt.second; ++eventIt )
+      ( (*eventIt).second )->process( command.c_str() );
+
+    if( ! ReleaseMutex( *syncMutex ) )
+    { writeOnLog( "Failed to Release the Mutex" ); continue; }
+
+    if( event == EV_CLOSE )
+      break;
+  }
+  writeOnLog( "P2P Thread: EXITING Loop" );
+  SetEvent( *syncEvent ); // Main thread can shut down now
+  return 0;
+}
+
+///////////////////////////
+/*void P2PControl::unregEventCB( bg_event_t event, EventHandlerWrap * eventCallback )
+{
+  std::pair< event_cb_map_t::iterator, event_cb_map_t::iterator > equalEventsIt;
+  // TODO
+  if( WaitForSingleObject( mSyncMutex, INFINITE ) == WAIT_FAILED )
+  { writeOnLog( "Failed to Lock the Mutex" ); return; }
+
+  equalEventsIt = mEventCBMap->equal_range( event );
+  for( eventIt = equalEventsIt.first; eventIt != equalEventsIt.second; ++eventIt )
+    ( (*eventIt).second )->process( command.c_str() );
+
+  if( ! ReleaseMutex( mSyncMutex ) )
+  { writeOnLog( "Failed to Release the Mutex" ); return; }
+}*/
+
+///////////////////////////
+void P2PControl::unregEventCB( bg_event_t event )
+{
+  if( WaitForSingleObject( mSyncMutex, INFINITE ) == WAIT_FAILED )
+  { writeOnLog( "Failed to Lock the Mutex" ); return; }
+
+  mEventCBMap.erase( event );
+
+  if( ! ReleaseMutex( mSyncMutex ) )
+  { writeOnLog( "Failed to Release the Mutex" ); return; }
+}
+
+#endif
Index: projects/mozilla/vlcplugin.cpp
===================================================================
--- projects/mozilla/vlcplugin.cpp	(.../trunk)	(revision 13995)
+++ projects/mozilla/vlcplugin.cpp	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -73,10 +73,17 @@
 #endif
 {
     memset(&npwindow, 0, sizeof(NPWindow));
+
 #if XP_UNIX
     memset(&npvideo, 0, sizeof(Window));
     memset(&npcontrol, 0, sizeof(Window));
 #endif
+
+#ifdef XP_WIN
+    // P2P-Next
+    p2pControl = new P2PControl();
+    p2pStatus = NULL;
+#endif
 }
 
 static bool boolValue(const char *value) {
@@ -103,7 +110,7 @@
     HKEY h_key;
     DWORD i_type, i_data = MAX_PATH + 1;
     char p_data[MAX_PATH + 1];
-    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\VideoLAN\\VLC",
+    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\SwarmPlugin",
                       0, KEY_READ, &h_key ) == ERROR_SUCCESS )
     {
          if( RegQueryValueEx( h_key, "InstallDir", 0, &i_type,
@@ -120,6 +127,11 @@
     }
     ppsz_argv[ppsz_argc++] = "--no-one-instance";
 
+    // P2P
+    if( ! p2pControl->startup() )
+      return NPERR_GENERIC_ERROR;
+
+
 #endif /* XP_MACOSX */
 
     /* common settings */
@@ -129,7 +141,13 @@
     ppsz_argv[ppsz_argc++] = "--ignore-config";
     ppsz_argv[ppsz_argc++] = "--intf=dummy";
     ppsz_argv[ppsz_argc++] = "--no-video-title-show";
+    ppsz_argv[ppsz_argc++] = "--no-osd";
+    // Arno: uncomment to enable logging
+    // ppsz_argv[ppsz_argc++] = "--extraintf=logger";
+    // ppsz_argv[ppsz_argc++] = "--logfile=C:\\VLC-logfile.txt";
 
+
+
     const char *progid = NULL;
 
     /* parse plugin arguments */
@@ -253,6 +271,22 @@
         // get absolute URL from src
         char *psz_absurl = getAbsoluteURL(psz_target);
         psz_target = psz_absurl ? psz_absurl : strdup(psz_target);
+
+#ifdef XP_WIN
+        writeOnLog( "VlcPlugin::init: target: %s", psz_target );
+
+
+        p2pControl->regEventCB< VlcPlugin >( EV_PLAY,   this, &VlcPlugin::onP2PPlay );
+        p2pControl->regEventCB< VlcPlugin >( EV_PAUSE,  this, &VlcPlugin::onP2PPause );
+        p2pControl->regEventCB< VlcPlugin >( EV_RESUME, this, &VlcPlugin::onP2PResume );
+        p2pControl->regEventCB< VlcPlugin >( EV_STOP,   this, &VlcPlugin::onP2PStop );
+        p2pControl->regEventCB< VlcPlugin >( EV_INFO,   this, &VlcPlugin::onP2PInfo );
+
+        if( ! p2pControl->sendTorrent( std::string( psz_target ) ) )
+        {  writeOnLog( "VlcPlugin::init: Could NOT send torrent" ); }
+        free(psz_target);
+        psz_target = NULL;
+#endif
     }
 
     /* assign plugin script root class */
@@ -264,6 +298,9 @@
 
 VlcPlugin::~VlcPlugin()
 {
+#if XP_WIN
+    delete p2pControl; // P2P
+#endif
     free(psz_baseURL);
     free(psz_target);
 
@@ -916,3 +953,108 @@
 }
 #undef BTN_SPACE
 #endif
+#if XP_WIN
+void VlcPlugin::onP2PPlay( const char * stream )
+{
+  writeOnLog( "VlcPlugin::onP2PPlay %s", stream );
+
+  if( libvlc_instance )
+  {
+    libvlc_exception_t ex;
+    libvlc_exception_init( &ex );
+
+    int item = playlist_add(stream, &ex );
+    if( item != -1 )
+    {
+      writeOnLog( "VlcPlugin::onP2PPlay: item %d", item );
+      if( b_autoplay )
+      {
+        libvlc_exception_t ex2;
+        libvlc_exception_init( &ex2 );
+        playlist_play(&ex2);
+        if( libvlc_exception_raised(&ex2) )
+        {
+           writeOnLog( libvlc_exception_get_message(&ex2) );
+           libvlc_exception_clear( &ex2 );
+           return;
+        }
+      }
+    }
+    else if( libvlc_exception_raised(&ex) )
+    {
+      writeOnLog( libvlc_exception_get_message(&ex) );
+      libvlc_exception_clear( &ex );
+      return;
+    }
+    b_stream = true;
+  }
+}
+
+void VlcPlugin::onP2PPause( const char * nothing )
+{
+  writeOnLog( "VlcPlugin::onP2PPause" );
+
+  libvlc_exception_t ex;
+  libvlc_exception_init( &ex );
+
+  playlist_pause( &ex );
+  if( libvlc_exception_raised(&ex) )
+  {
+    writeOnLog( libvlc_exception_get_message(&ex) );
+    libvlc_exception_clear( &ex );
+    return;
+  }
+}
+
+void VlcPlugin::onP2PResume( const char * nothing )
+{
+  writeOnLog( "VlcPlugin::onP2PResume" );
+
+  libvlc_exception_t ex;
+  libvlc_exception_init( &ex );
+
+  playlist_play( &ex );
+  if( libvlc_exception_raised(&ex) )
+  {
+    writeOnLog( libvlc_exception_get_message(&ex) );
+    libvlc_exception_clear( &ex );
+    return;
+  }
+}
+
+void VlcPlugin::onP2PStop( const char * nothing )
+{
+  writeOnLog( "VlcPlugin::onP2PStop" );
+
+  libvlc_exception_t ex;
+  libvlc_exception_init( &ex );
+
+  playlist_stop( &ex );
+  if( libvlc_exception_raised(&ex) )
+  {
+    writeOnLog( libvlc_exception_get_message(&ex) );
+    libvlc_exception_clear( &ex );
+    return;
+  }
+}
+
+void VlcPlugin::onP2PInfo( const char * infostr )
+{
+    // Save copy of status message
+	if (this->p2pStatus != NULL)
+	{
+		free(this->p2pStatus);
+	}
+	this->p2pStatus = (char *)malloc((strlen(infostr)+1)*sizeof(char));
+	strcpy(this->p2pStatus,infostr);
+}
+
+// For JavaScript API
+const char *VlcPlugin::getP2PStatus()
+{
+        if (this->p2pStatus == NULL)
+		return "";
+	else
+		return this->p2pStatus;
+}
+#endif
Index: projects/mozilla/p2pcontrol.h
===================================================================
--- projects/mozilla/p2pcontrol.h	(.../trunk)	(revision 0)
+++ projects/mozilla/p2pcontrol.h	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -0,0 +1,202 @@
+/*
+ * Written by Diego Andres Rabaioli
+ * see P2P-Next-LICENSE.txt for license information
+ */
+
+#ifndef _PEER2PEERCONTROL_H
+#define _PEER2PEERCONTROL_H
+
+#include <winsock2.h>
+#include <string>
+#include <map>
+
+
+////////////////////////
+//
+// This class represents the communication layer between the Plug-in
+// and the BG Process. It sends and receives events through a TCP
+// socket. It receives commands in an asynchronous way. A thread
+// implements the event loop: it's mainly blocked in a recv call,
+// as soon as it receives an event from the BG process, it calls
+// all the handlers registered for that event. The communication
+// protocol it's basic: after the connection with the remote
+// process, the P2PControl sends the MRL ( media resource
+// locator) of the torrent to the BG, when the stream is available,
+// a 'PLAY' event is sent back and the handler for that event is
+// called. Since it's intended to work as a library, external code
+// can use the P2P control by registering their handler functions.
+//
+////////////////////////
+
+void writeOnLog( const char * msg, ... );
+
+///////////////////////////
+// BGPConnection
+///////////////////////////
+
+// States enumerations
+enum sock_state_t { S_DOWN, S_STARTED, S_CREATED, S_UP };
+
+const int         IN_BUF_LEN = 512;
+const int         BG_PORT    = 62062;
+const std::string BG_ADDRESS = "127.0.0.1";
+
+class BGPConnection
+{
+ public:
+  BGPConnection( const int port, const std::string bgAddress );
+  ~BGPConnection();
+
+  bool connect();
+  bool disconnect();
+
+  bool sendMsg( const std::string & ) const;
+  bool recvMsg( std::string & ) const;
+
+  std::string  getAddress() { return mBGAddress; }
+  int          getPort()    { return mPort; }
+
+ private:
+  SOCKET       mServerSocket;
+  std::string  mBGAddress;
+  int          mPort;
+  sock_state_t mSocketState;
+};
+
+///////////////////////////
+// EventHandlerWrap
+///////////////////////////
+class EventHandlerWrap
+{
+ public:
+  virtual void process( const char * ) const = 0;
+  virtual ~EventHandlerWrap() {}
+};
+
+///////////////////////////
+class EventHandlerWrap_Static : public EventHandlerWrap
+{
+ public:
+  EventHandlerWrap_Static( void ( *handler )( const char * ) ):
+    mSHandler( handler ) {}
+
+  virtual ~EventHandlerWrap_Static() {}
+
+  virtual void process( const char * c ) const
+  {
+    mSHandler( c );
+  }
+
+ private:
+  void ( *mSHandler )( const char * );
+
+};
+
+///////////////////////////
+template < class T >
+class EventHandlerWrap_NonStatic : public EventHandlerWrap
+{
+ public:
+  EventHandlerWrap_NonStatic( T * obj, void ( T::* handler )( const char * ) ):
+    mObject( obj ), mNHandler( handler ) {}
+
+  virtual ~EventHandlerWrap_NonStatic() {}
+
+  virtual void process( const char * c ) const
+  {
+    (mObject->*mNHandler)( c );
+  }
+
+ private:
+  T * mObject;
+  void ( T::* mNHandler )( const char * );
+};
+
+///////////////////////////
+// P2PControl
+///////////////////////////
+
+// Constants
+const char PLUGIN_REG_KEY[]   = "Software\\SwarmPlugin";
+const char BG_PATH_ELEMENT[]  = "BGProcessPath";
+const char LOG_PATH_ELEMENT[] = "InstallDir";
+const char LOG_FILE_NAME[]    = "swarmplugin.log";
+
+// Event Callback types
+enum bg_event_t { EV_NONE, EV_PLAY, EV_PAUSE, EV_RESUME, EV_STOP, EV_INFO, EV_CLOSE };
+typedef std::multimap< bg_event_t, EventHandlerWrap * > event_cb_map_t;
+typedef std::pair< bg_event_t, EventHandlerWrap * >     event_cb_item_t;
+
+// Thread parameters
+typedef struct {  BGPConnection *  connection;
+                  event_cb_map_t * eventMap;
+                  HANDLE *         syncEvent;
+                  HANDLE *         syncMutex;
+               } ThreadParams;
+
+// States enumerations
+enum protocol_status_t { P_DOWN, P_UP, P_CLOSING };
+
+class P2PControl
+{
+ public:
+  P2PControl( const int port = BG_PORT, const std::string bgAddress = BG_ADDRESS );
+  ~P2PControl();
+
+  bool  startup();
+  bool  shutdown();
+
+  bool  launchBGProcess( const char * cmd = NULL );
+  bool  sendTorrent( const std::string torrent );
+
+  void  regEventCB( bg_event_t event, void (*callback)( const char * ) )
+  {
+    if( WaitForSingleObject( mSyncMutex, INFINITE ) == WAIT_FAILED )
+      { writeOnLog( "Failed to Lock the Mutex" ); return; }
+
+    EventHandlerWrap * wrap = new EventHandlerWrap_Static( callback );
+    mEventCBMap.insert( event_cb_item_t( event, wrap ) );
+
+    if( ! ReleaseMutex( mSyncMutex ) )
+      { writeOnLog( "Failed to Release the Mutex" ); return; }
+  }
+
+  template < class T >
+  void  regEventCB( bg_event_t event, T * obj, void ( T::* callback)( const char * ) )
+  {
+    if( WaitForSingleObject( mSyncMutex, INFINITE ) == WAIT_FAILED )
+      { writeOnLog( "Failed to Lock the Mutex" ); return; }
+
+    EventHandlerWrap * wrap = new EventHandlerWrap_NonStatic< T >( obj, callback );
+    mEventCBMap.insert( event_cb_item_t( event, wrap ) );
+
+    if( ! ReleaseMutex( mSyncMutex ) )
+      { writeOnLog( "Failed to Release the Mutex" ); return; }
+  }
+
+  //void  unregEventCB( bg_event_t, EventHandlerWrap * );
+  void  unregEventCB( bg_event_t );
+
+  // DEBUG
+  void setProtoState( protocol_status_t newState ) { mProtoState = newState; }
+ private:
+  // Thread utilities
+  const BGPConnection *  getConnection() const { return mConnection; }
+  const event_cb_map_t * getEventMap()   const { return &mEventCBMap; }
+  // Event Loop: receives events from BG and call the registered handlers
+  static DWORD WINAPI    eventLoop( LPVOID );
+  // Back Ground Process
+  static bool            startBGProcess();
+
+  // Variable Members
+  BGPConnection *   mConnection;
+  protocol_status_t mProtoState;
+
+  // Thread and Sync
+  event_cb_map_t    mEventCBMap;  // Association event/callback
+  HANDLE            mEventThread; // Thread handler
+  HANDLE            mSyncEvent;   // Syncronize the thread at startup and shutdown time
+  HANDLE            mSyncMutex;   // Syncronize access to the Event Map
+};
+
+#endif
Index: projects/mozilla/Makefile.am
===================================================================
--- projects/mozilla/Makefile.am	(.../trunk)	(revision 13995)
+++ projects/mozilla/Makefile.am	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -11,6 +11,8 @@
 	vlcshell.h \
 	vlcplugin.cpp \
 	vlcplugin.h \
+	p2pcontrol.cpp \
+	p2pcontrol.h \
 	control/npolibvlc.cpp \
 	control/npolibvlc.h \
 	control/nporuntime.cpp \
@@ -35,11 +37,11 @@
 
 SOURCES_support = support/npwin.cpp
 CPPFLAGS_mozilla_EXTRA = -DXP_WIN -DXP_WIN32
-LDFLAGS_mozilla_EXTRA = -no-undefined -Wl,--kill-at -Wl,$(DATA_npvlc_rc)
+LDFLAGS_mozilla_EXTRA = -lws2_32 -no-undefined -Wl,--kill-at -Wl,$(DATA_npvlc_rc)
 
 npvlc_la_SOURCES = $(SOURCES_mozilla_common) $(SOURCES_support)
-npvlc_la_CFLAGS = `$(VLC_CONFIG) --cflags mozilla` $(CPPFLAGS_mozilla_extra)
-npvlc_la_CXXFLAGS = `$(VLC_CONFIG) --cxxflags mozilla` $(CPPFLAGS_mozilla_extra)
+npvlc_la_CFLAGS = `$(VLC_CONFIG) --cflags mozilla` $(CPPFLAGS_mozilla_EXTRA)
+npvlc_la_CXXFLAGS = `$(VLC_CONFIG) --cxxflags mozilla` $(CPPFLAGS_mozilla_EXTRA)
 npvlc_la_DEPENDENCIES = $(DATA_npvlc_rc) $(LIBRARIES_libvlc)
 npvlc_la_LDFLAGS = `$(VLC_CONFIG) --ldflags mozilla` -module -avoid-version \
 				   $(LDFLAGS_mozilla_EXTRA)
Index: projects/mozilla/vlcplugin.h
===================================================================
--- projects/mozilla/vlcplugin.h	(.../trunk)	(revision 13995)
+++ projects/mozilla/vlcplugin.h	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -41,6 +41,8 @@
 
 #ifdef XP_WIN
     /* Windows stuff */
+    // P2P
+    #include "p2pcontrol.h"
 #endif
 
 #ifdef XP_MACOSX
@@ -79,6 +81,7 @@
     clicked_Unmute
 } vlc_toolbar_clicked_t;
 
+
 class VlcPlugin
 {
 public:
@@ -195,6 +198,20 @@
 
     bool  player_has_vout( libvlc_exception_t * );
 
+#if XP_WIN
+    // P2P-Next
+    P2PControl *   getP2PControl() { return p2pControl; }
+    void               onP2PPlay  ( const char * );
+    void               onP2PPause ( const char * );
+    void               onP2PResume( const char * );
+    void               onP2PStop  ( const char * );
+    void               onP2PInfo  ( const char * );
+
+    // For JavaScript API
+    const char *       getP2PStatus();
+#endif
+
+
 private:
     bool playlist_select(int,libvlc_exception_t *);
     void set_player_window( libvlc_exception_t * );
@@ -214,7 +231,11 @@
     NPWindow  npwindow;
 #if XP_WIN
     WNDPROC   pf_wndproc;
-#endif
+    // P2P
+    P2PControl * p2pControl;
+    char *		 p2pStatus;
+
+    #endif
 #if XP_UNIX
     unsigned int     i_width, i_height;
     unsigned int     i_tb_width, i_tb_height;
@@ -236,12 +257,14 @@
 /*******************************************************************************
  * Plugin properties.
  ******************************************************************************/
-#define PLUGIN_NAME         "VLC Multimedia Plug-in"
+#define PLUGIN_NAME         "SwarmPlugin Multimedia Player"
 #define PLUGIN_DESCRIPTION \
     "Version %s, copyright 1996-2007 The VideoLAN Team" \
     "<br><a href=\"http://www.videolan.org/\">http://www.videolan.org/</a>"
 
 #define PLUGIN_MIMETYPES \
+    "application/x-ns-stream;"
+#if 0
     /* MPEG-1 and MPEG-2 */ \
     "audio/mpeg:mp2,mp3,mpga,mpega:MPEG audio;" \
     "audio/x-mpeg:mp2,mp3,mpga,mpega:MPEG audio;" \
@@ -294,5 +317,6 @@
     "audio/x-matroska:mka:Matroska audio;" \
     /* XSPF */ \
     "application/xspf+xml:xspf:Playlist xspf;"
+#endif
 
 #endif
Index: projects/mozilla/npvlc_rc.rc.in
===================================================================
--- projects/mozilla/npvlc_rc.rc.in	(.../trunk)	(revision 13995)
+++ projects/mozilla/npvlc_rc.rc.in	(.../tags/vlc-1.0.1-swarmplugin+raw-src-nov2009)	(revision 13995)
@@ -1,8 +1,8 @@
 /////////////////////////////////////////////////////////////////////////////
 //
-//  VLC Plugin description.
+//  SwarmPlayer Plugin description.
 //
-#define VERSION_NUMBER @VERSION_MAJOR@,@VERSION_MINOR@,@VERSION_REVISION@,@VERSION_EXTRA_RC@ 
+#define VERSION_NUMBER 1,0,3,0
 
 //VS_VERSION_INFO VERSIONINFO
 1 VERSIONINFO
@@ -23,17 +23,17 @@
     BEGIN
         BLOCK "040904e4"
         BEGIN
-            VALUE "ProductName", "VLC Multimedia Plug-in\0"
-            VALUE "ProductVersion", "@VERSION@"
+            VALUE "ProductName", "SwarmPlugin P2P Multimedia Plug-in\0"
+            VALUE "ProductVersion", "1.0.3"
             VALUE "OriginalFilename", "npvlc.dll\0"
-            VALUE "FileVersion", "@VERSION@"
-            VALUE "FileDescription", "Version @VERSION@, copyright @COPYRIGHT_YEARS@ The VideoLAN Team<br><a href=""http://www.videolan.org/"">http://www.videolan.org/</a>\0"
+            VALUE "FileVersion", "1.0.3"
+            VALUE "FileDescription", "SwarmPlugin Version 1.0.3, Copyright (c) 2009, the VideoLAN Team and Delft University of Technology<br><a href=""http://www.pds.ewi.tudelft.nl/code.html"">http://www.pds.ewi.tudelft.nl/code.html</a>\0"
             VALUE "InternalName", "npvlc\0"
-            VALUE "CompanyName", "the VideoLAN Team\0"
-            VALUE "LegalCopyright", "Copyright \251 @COPYRIGHT_YEARS@ The VideoLAN Team\0"
-            VALUE "MIMEType", "audio/mpeg|audio/x-mpeg|video/mpeg|video/x-mpeg|video/mpeg-system|video/x-mpeg-system|video/mp4|audio/mp4|application/mpeg4-iod|application/mpeg4-muxcodetable|video/x-msvideo|video/quicktime|application/x-ogg|application/ogg|application/x-vlc-plugin|video/x-ms-asf-plugin|video/x-ms-asf|application/x-mplayer2|video/x-ms-wmv|application/x-google-vlc-plugin|audio/wav|audio/x-wav|audio/3gpp|video/3gpp|audio/3gpp2|video/3gpp2|video/divx|video/flv|video/x-flv|video/x-matroska|audio/x-matroska|application/xspf+xml|audio/x-m4a|audio/x-mpegurl|audio/x-ms-wma\0"
-            VALUE "FileExtents", "mp2,mp3,mpga,mpega|mp2,mp3,mpga,mpega|mpg,mpeg,mpe|mpg,mpeg,mpe|mpg,mpeg,vob|mpg,mpeg,vob|mp4,mpg4|mp4,mpg4|mp4,mpg4|mp4,mpg4|avi|mov,qt|ogg|ogg|vlc|asf,asx|asf,asx||wmv||wav|wav|3gp,3gpp|3gp,3gpp|3g2,3gpp2|3g2,3gpp2|divx|flv|flv|mkv|mka|xspf|m4a|m3u|wma\0"
-            VALUE "FileOpenName", "MPEG audio|MPEG audio|MPEG video|MPEG video|MPEG video|MPEG video|MPEG-4 video|MPEG-4 audio|MPEG-4 video|MPEG-4 video|AVI video|QuickTime video|Ogg stream|Ogg stream|VLC plug-in|Windows Media video|Windows Media video|Windows Media plug-in|Windows Media video|Google VLC plug-in|WAV audio|WAV audio|3GPP audio|3GPP video|3GPP2 audio|3GPP2 video|DivX video|FLV video|FLV video|Matroska video|Matroska audio|Playlist xspf|MPEG-4 audio|Playlist M3U|Windows Media Audio\0"
+            VALUE "CompanyName", "the VideoLAN Team and Delft University of Technology\0"
+            VALUE "LegalCopyright", "Copyright \251 2009 the VideoLAN Team and Delft University of Technology\0"
+            VALUE "MIMEType", "application/x-ns-stream\0"
+            VALUE "FileExtents", "torrent\0"
+            VALUE "FileOpenName", "Torrent Video\0"
         END
     END
     BLOCK "VarFileInfo"
